---
title: MySQL之索引底层原理
date: 2021-05-03 21:08:22
tags: ['MySQL', '底层原理']
---

### InnoDB 页结构

`页`是`MySQL`管理存储空间的基本单位，一个页的大小一般是`16KB`，记录是被存放在`页`中的，如果记录占用的空间太大还可能造成`行溢出`现象，这会导致一条记录被分散存储在多个页中。

`页`的本质就是一块`16KB`大小的存储空间，`InnoDB`为了不同的目的而把`页`分为不同的类型，其中用于存放记录的页也称为`数据页`，我们先看看这个用于存放记录的页长什么样。**数据页代表的这块`16KB`大小的存储空间可以被划分为多个部分，不同部分有不同的功能**，各个部分如图所示：



![image-20210309131556552](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210309131556552.png)



##### 页结构解释

| 名称                     | 中文名             | 占用空间 | 简单描述                 |
| ------------------------ | ------------------ | -------- | ------------------------ |
| File Header              | 文件头部           | 38字节   | 页的一些通用信息         |
| Page Header              | 页面头部           | 56字节   | 数据页专有的一些信息     |
| * **Infimum + Supremum** | 最小记录和最大记录 | 26字节   | 两个虚拟的行记录         |
| * **User Records**       | 用户记录           | 不确定   | 实际存储的行记录内容     |
| * **Free Space**         | 空闲空间           | 不确定   | 页中尚未使用的空间       |
| * **Page Directory**     | 页面目录           | 不确定   | 页中的某些记录的相对位置 |
| File Trailer             | 文件尾部           | 8字节    | 校验页是否完整           |

在页的7个组成部分中，存储的记录会按照指定的`行格式`存储到 `User Records` 部分。但是在一开始生成页的时候，其实并没有`User Records`这个部分，每当插入一条记录，都会从 `Free Space` 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records`部分，**当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了**，这个过程的图示如下：

![image-20210309132643141](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210309132643141.png)



- **各个数据页**之间可以组成一个**双向链表** （就是B+树的各个页之间都按照**索引值顺序**用双向链表连接起来）
- 而**每个数据页中的记录**又可以组成一个**单向**链表
- 每个数据页都会为存储在它里边的记录生成一个**页目录**，该目录页是用**数组**进行管理，在通过**主键**查找某条记录的时候可以在页目录中使用**二分法快速定位**到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
- 以**其他列**(非主键)作为搜索条件：只能从最小记录开始**依次遍历单链表中的每条记录**。

### InnoDB的行存储结构 

一页存放多条行记录，InnoDB支持以下四种行记录格式：

- Compact
- Redundant
- Compressed
- Dynamic (现阶段默认)

> 因为后续的行记录都是根据Compact来做改变的，所以只介绍Compact格式

行记录格式：

![image-20210309135239935](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210309135239935.png)

##### 记录头信息

除了变长字段长度列表、NULL值列表之外，还有一个用于描述记录的记录头信息，**它是由固定的5个字节组成**。 5个字节也就是40个二进制位，不同的位代表不同的意思，如下表：

| 名称         | 大小（单位：**bit**） | 描述                                                         |
| ------------ | --------------------- | ------------------------------------------------------------ |
| 预留位1      | 1                     | 没有使用                                                     |
| 预留位2      | 1                     | 没有使用                                                     |
| delete_mask  | 1                     | 这个属性标记着当前记录是否被删除，占用1个二进制位，值为`0`的时候代表记录并没有被删除，为`1`的时候代表记录被删除掉了。 |
| min_rec_mask | 1                     | B+树的每层非叶子节点中的最小记录都会添加该标记，目的是为了加快检索速度 |
| n_owned      | 4                     | 表示当前记录拥有的记录数                                     |
| heap_no      | 13                    | 表示当前记录在**本页中**的位置信息                           |
| record_type  | 3                     | 当前记录的类型，0表示普通记录，1表示非叶子节点记录，2表示最小记录，3表示最大记录 |
| next_record  | 16                    | 表示下一条记录的相对位置                                     |

- **delete_mask**：这个属性标记着当前记录是否被删除，占用1个二进制位，值为`0`的时候代表记录并没有被删除，为`1`的时候代表记录被删除掉了，这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打个删除标记而已，而且这部分存储空间之后还可以重用，也就是说之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空
- min_rec_mask： B+树的每层非叶子节点中的最小记录都会添加该标记，目的是为了加快检索速度
- heap_no ：**这个属性表示当前记录在本`页`中的位置**。`InnoDB`自动给每个页里加了两个记录，由于这两个记录并不是自己插入的，所以有时候也称为`伪记录`或者`虚拟记录`。这两个伪记录一个代表`最小记录`，一个代表`最大记录`。对于一条完整的记录来说，比较记录的大小就是比较`主键`的大小。不管我们向`页`中插入了多少自己的记录，`InnoDB`都定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的`记录头信息`和8字节大小的一个固定的部分组成的

![image-20210309140453278](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210309140453278.png)

​		**最小记录和最大记录的`heap_no`值分别是`0`和`1`，也就是说它们的位置最靠前**

- **next_record**：这个非常重要，**它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量**。比方说第一条记录的`next_record`值为`36`，意味着从第一条记录的真实数据的地址处向后找`36`个字节便是下一条记录的真实数据。这其实是个`链表`，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，`下一条记录`指得并不是按照插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且**规定 _最小记录_ 的下一条记录就本页中主键值最小的记录，而本页中主键值最大的记录的下一条记录就是 _最大记录_** ，为了更形象的表示一下这个`next_record`起到的作用，用箭头来替代一下`next_record`中的地址偏移量：

![image-20210309141340963](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210309141340963.png)

##### **记录真实数据**

记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：

| 列名           | 是否必须 | 占用空间 | 描述                   |
| -------------- | -------- | -------- | ---------------------- |
| row_id         | 否       | 6字节    | 行ID，唯一标识一条记录 |
| transaction_id | 是       | 6字节    | 事务ID                 |
| roll_pointer   | 是       | 7字节    | 回滚指针               |

> 只有未设置主键时，innodb才会创建row_id来作为主键列

##### 页目录

InnoDB为记录制作了一个目录，制作过程是这样的：

- 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组
  - 对于最小记录所在的分组只能有 **1 **条记录，最大记录所在的分组拥有的记录条数只能在 **1~8** 条之间
  - 剩下的分组中记录的条数范围只能在是 **4~8** 条之间
  - 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 之后每插入一跳记录都把这条记录放到最大记录所在的组，直到最大记录所在组中的记录数等于8个。 在最大记录所在组中的记录数等于8个的时候再插入一条记录时，将最大记录所在组平均分裂成2个组，然后最大记录所在的组就剩下4条记录了，然后就可以把即将插入的那条记录放到对应的组中
- **每个组的最后一条记录的头信息中的 n_owned 属性表示该组内共有几条记录**
- **将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个槽**（英文名：Slot）

这些地址偏移量会被存储到页结构中的 **Page Directory** 中，（可以看前面[**页的结构**](#页结构解释) ），比方说现在的表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：

![image-20210309144102919](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210309144102919.png)

现在`Page Directory`部分中有两个槽，也就意味着我们的记录被分成了两个组，`槽0`中的值是`99`，代表最小记录的地址偏移量；`槽1`中的值是`122`，代表最大记录的地址偏移量。 注意最小和最大记录的头信息中的`n_owned`属性，最小记录的`n_owned`值为`1`，这就代表着以最小记录结尾的这个分组中只有`1`条记录，也就是最小记录本身。 最大记录的`n_owned`值为`5`，这就代表着以最大记录结尾的这个分组中只有`5`条记录，包括最大记录本身还有自己插入的`4`条记录。



### B+树索引

InnoDB数据页的主要组成部分。各个数据页可以组成一个双向链表，而每个**数据页**中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边儿的记录生成一个**页目录**。再通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽。

![image-20210315132707169](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210315132707169.png)

**在一个页中的查找**

- 以主键为搜索条件
  这个查找过程我们已经很熟悉了，可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
- 以其他列作为搜索条件
  对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件

**在很多页中查找**

1. 定位到记录所在的页。
2. 从所在的页内中查找相应的记录。

在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录

**索引**

为了我们理解上的方便，我们简化了一下index_demo表的行格式示意图

![image-20210315133023585](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210315133023585.png)



**record_type**
这个属性表示当前记录的类型，一共有4种类型的记录，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录。
**next_record**
记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量

把一些记录放到页里边的示意图就是：

![image-20210315133136581](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210315133136581.png)

由于数据页的编号可能并不是连续的，所以在向表中插入许多条记录后，可能是这样的效果：

![2d3f897b76d42e02a0c371beef9348e21603800405473](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/2d3f897b76d42e02a0c371beef9348e21603800405473.png)



因为这些16KB的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：
	\* 页的记录中**最小的主键值**，我们用key来表示。
	\* 页号，我们用page_no表示。

在InnoDB中复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录

![image-20210315134405397](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210315134405397.png)

如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？其实也简单，为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：

![image-20210315135330807](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210315135330807.png)

所以随着目录的增加，目录的层级就继续增加：

![image-20210315135553476](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210315135553476.png)

**聚簇索引**

我们上边介绍的B+树本身就是一个目录，或者说本身就是一个索引。它有两个特点：

1. 使用记录主键值的大小进行记录和页的排序
2. B+树的叶子节点存储的是完整的用户记录。

我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建MySQL中事务的创建

**二级索引**

![image-20210315140743239](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210315140743239.png)

这个B+树与上边介绍的聚簇索引有几处不同：

- 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：
- - 页内的记录是按照c2列的大小顺序排成一个单向链表。
  - 各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。
  - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表。
- B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值。
- 目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。

**联合索引**



![image-20210315141037244](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210315141037244.png)

如图所示，我们需要注意一下几点：

- 每条目录项记录都由c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序。
- B+树叶子节点处的用户记录由c2、c3和主键c1列组成。



**B+树适用的条件**

那么再次建议回过头把前边的内容看完了再来，要不然读文章对你来说是一种折磨。首先，B+树索引并不是万能的，并不是所有的查询语句都能用到我们建立的索引。下边介绍几个我们可能使用B+树索引来进行查询的情况。

```
CopyCREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

person_info表会为聚簇索引和idx_name_birthday_phone_number索引建立2棵B+树。

在记录结构中只保留name、birthday、phone_number、id这四个列的真实数据值，所以示意图就长这样：
![MySQL中InnoDB及索引深入剖析35](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210315143231164.png)

内节点中存储的是目录项记录，叶子节点中存储的是用户记录（由于不是聚簇索引，所以用户记录是不完整的，缺少country列的值）。

- 先按照name列的值进行排序。
- 如果name列的值相同，则按照birthday列的值进行排序。
- 如果birthday列的值也相同，则按照phone_number的值进行排序。

#### 全值匹配

如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：

```
CopySELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

- 因为B+树的数据页和记录先是按照name列的值进行排序的，所以先可以很快定位name列的值是Ashburn的记录位置。
- 在name列相同的记录里又是按照birthday列的值进行排序的，所以在name列的值是Ashburn的记录里又可以快速定位birthday列的值是'1990-09-27'的记录。
- 如果很不幸，name和birthday列的值都是相同的，那记录是按照phone_number列的值排序的，所以联合索引中的三个列都可能被用到。

调换name、birthday、phone_number这几个搜索列的顺序对查询的执行过程是没有影响的。

#### 匹配左边的列

```
CopySELECT * FROM person_info WHERE name = 'Ashburn';
```

或者包含多个左边的列也行：

```
CopySELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
```

只有左边的列才能匹配，下边的语句就用不到这个B+树索引：

```
CopySELECT * FROM person_info WHERE birthday = '1990-09-27';
```

因为B+树的数据页和记录先是按照name列的值排序的，在name列的值相同的情况下才使用birthday列进行排序，也就是说name列的值不同的记录中birthday的值可能是无序的。

如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列。

#### 匹配列前缀

person_info表上建立的联合索引idx_name_birthday_phone_number会先用name列的值进行排序。

也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，比方说我们想查询名字以'As'开头的记录，那就可以这么写查询语句：

```
CopySELECT * FROM person_info WHERE name LIKE 'As%';
```

同理，这样也是无法匹配的：

```
CopySELECT * FROM person_info WHERE name LIKE '%As%';
```

#### 匹配范围值

所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。

```
CopySELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来喽～
找到这些记录的主键值，再到聚簇索引中回表查找完整的记录。

如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+树索引，比方说这样：

```
CopySELECT * FROM person_info WHERE name > ‘Asa’ AND name < ‘Barlow’
AND birthday > '1980-01-01';
```

上边这个查询可以分成两个部分：

1. 通过条件name > 'Asa' AND name < 'Barlow'来对name进行范围。
2. 对这些name值不同的记录继续通过birthday > '1980-01-01'条件继续过滤。

对于联合索引idx_name_birthday_phone_number来说，只能用到name列的部分，而用不到birthday列的部分，**因为只有name值相同的情况下才能用birthday列的值进行排序，而这个查询中通过name进行范围查找的记录中可能并不是按照birthday列进行排序的**，所以在搜索条件中继续以birthday列进行查找时是用不到这个B+树索引的。

#### 精确匹配某一列并范围匹配另外一列

虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：

```
CopySELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

由于name列是精确查找，所以通过name = 'Ashburn'条件查找后得到的结果的name值都是相同的，它们会再按照birthday的值进行排序。所以此时对birthday列进行范围查找是可以用到B+树索引的。

phone_number > '15100000000'，通过birthday的范围查找的记录的birthday的值可能不同，所以这个条件无法再利用B+树索引了，只能遍历上一步查询得到的记录。

#### 用于排序

有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在MySQL中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：filesort）。

但是如果ORDER BY子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：

```
CopySELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

因为这个B+树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。

**使用联合索引进行排序注意事项**
ORDER BY的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出ORDER BY phone_number, birthday, name的顺序，那也是用不了B+树索引。

#### 不可以使用索引进行排序的几种情况

1.ASC、DESC混用
对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是ASC规则排序，要么都是DESC规则排序。

idx_name_birthday_phone_number联合索引中记录的结构：

- 先按照记录的name列的值进行升序排列。
- 如果记录的name列的值相同，再按照birthday列的值进行升序排列。
- 如果记录的birthday列的值相同，再按照phone_number列的值进行升序排列。

2.WHERE子句中出现非排序使用到的索引列
如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，比方说这样：

```
CopySELECT * FROM person_info WHERE country = ‘China’ ORDER BY name LIMIT 10;
```

这个查询只能先把符合搜索条件country = 'China'的记录提取出来后再进行排序，是使用不到索引。

3.排序列包含非同一个索引的列
有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：

```
CopySELECT * FROM person_info ORDER BY name, country LIMIT 10;
```

4.排序列使用了复杂的表达式
要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：

```
CopySELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;
```

## 回表的代价

还是用idx_name_birthday_phone_number索引为例，看下边这个查询：

```
CopySELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

在使用idx_name_birthday_phone_number索引进行查询时大致可以分为这两个步骤：

1. 从索引idx_name_birthday_phone_number对应的B+树中取出name值在Asa～Barlow之间的用户记录。
2. 由于索引idx_name_birthday_phone_number对应的B+树用户记录中只包含name、birthday、phone_number、id这4个字段，而查询列表是*，意味着要查询表中所有字段，也就是还要包括country字段。这时需要把从上一步中获取到的每一条记录的id字段都到聚簇索引对应的B+树中找到完整的用户记录，也就是我们通常所说的回表，然后把完整的用户记录返回给查询用户。

读取索引idx_name_birthday_phone_number数据中，在Asa～Barlow之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为**顺序I/O**。

而获取到的记录的id字段的值可能并不相连，而在聚簇索引中记录是根据id（也就是主键）的顺序排列的，所以根据这些并不连续的id值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为**随机I/O**。

所以这个使用索引idx_name_birthday_phone_number的查询有这么两个特点：

- 会使用到两个B+树索引，一个二级索引，一个聚簇索引。
- 访问二级索引使用顺序I/O，访问聚簇索引使用随机I/O。

需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用二级索引。比方说name值在Asa～Barlow之间的用户记录数量占全部记录数量90%以上，那么如果使用idx_name_birthday_phone_number索引的话，有90%多的id值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。

查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引 + 回表的方式。

比方说上边的查询可以改写成这样：

```
CopySELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;
```

添加了LIMIT 10的查询更容易让优化器采用二级索引 + 回表的方式进行查询。

### 覆盖索引

为了彻底告别回表操作带来的性能损耗，我们建议：最好在查询列表里只包含索引列。

```
CopySELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
```

因为我们只查询name, birthday, phone_number这三个索引列的值，所以在通过idx_name_birthday_phone_number索引得到结果后就不必到聚簇索引中再查找记录的剩余列，也就是country列的值了，这样就省去了回表操作带来的性能损耗。

我们把这种只需要用到索引的查询方式称为索引覆盖。

我们很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明。

### 索引失效的情况

![3602225017-48d7f65c7b440c51](MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/3602225017-48d7f65c7b440c51.png)

[具体情况参考网站](https://segmentfault.com/a/1190000021464570?utm_source=sf-similar-article)

## 如何挑选索引

### 只为用于搜索、排序或分组的列创建索引

也就是说，只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了

```
CopySELECT birthday, country FROM person_name WHERE name = 'Ashburn';
```

### 考虑列的基数

记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。

假设某个列的基数为1，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了。

而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。

### 索引列的类型尽量小

如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型。
因为：

- 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。

### 让索引列在比较表达式中单独出现

如：

1. WHERE my_col * 2 < 4
2. WHERE my_col < 4/2

第1个WHERE子句中my_col列并不是以单独列的形式出现的，而是以my_col * 2这样的表达式的形式出现的，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于4。

如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。

### 主键插入顺序

对于一个使用InnoDB存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插。

如果我们插入的主键值忽大忽小的话，就会需要页分裂和记录移位，意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。

所以我们建议：让主键具有AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入。

