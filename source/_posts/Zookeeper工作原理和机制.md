---
title: Zookeeper工作原理和机制
date: 2021-05-03 20:37:38
tags:
- 中间件
- Zookeeper
- 底层原理
---

# Zookeeper工作机制

是一个分布式服务管理框架，负责存储和管理数据，然后接受观察者的注册，一旦这些数据发生变化，zookeeper就负责通知这些观察者做出相应的反应

## Zookeeper服务器角色

一般zookeeper都是以集群的形式存在的，是一个基于主从复制的高可用集群，每个服务器承担三个角色的一种：

- **Leader：**一个集群只有有一个Leader，他会发起并维护各Follwer和Observer间的心跳，所有的写操作都会Leader来进行完成并将写操作广播给其他Follwer
- **Follower：**可同时存在多个，它会响应Leader的心跳，它可以直接处理并返回客户端的读请求，但如果是写请求，会将请求转发给Leader处理，并负责对Leader的写请求进行投票
- **Observer：**和Follower类似，但是无投票权

![image-20210407141352648](Zookeeper%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%9C%BA%E5%88%B6/image-20210407141352648.png)

## Zookeeper怎么保证读写操作的一致性和可用性？

使用的是原子广播(ZAB)来实现，根据ZAB协议，所有的写操作都需要通过 Leader 来完成，Leader 写入本地日志后再复制到所有的Follower节点上，而一旦Leader节点无法工作，ZAB协议能够自动从Follower节点中重新选出一个合适的替代者

## 写Leader

![image-20210407155421726](Zookeeper%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%9C%BA%E5%88%B6/image-20210407155421726.png)

如果通过Leader进行写操作，会进行下列步骤：

- 客户端向Leader发送写请求
- Leader将写请求以**提议**的形式发送给所有的Follower并等待确认
- Follower收到Leader的提议后返回确认
- Leader得到**过半数**的确认(Leader对自己默认有一个ACK)后向所有的Follower发送commit，并将结果返回客户端

> 对于上图的4各Follower，那就是一共有5个节点(不用计算Observer)，那就是需要3个确认，也就是两个Follower的ACK即可

## 写Follower

- Follower/Observer均可接受写请求，但不能直接处理，而需要将写请求转发给Leader处理
- 除了多了一步请求转发，其它流程与直接写Leader无任何区别

## 读操作

所有服务器都可以接受客户端的读操作

## 领导选举算法 - FastLeaderElection

FastLeaderElection 是基于TCP的

##### 1.myid

每个zookeeper服务器都要在数据文件夹下创建一个叫做myid的文件，这个文件包含整个zookeeper集群的唯一id

##### 2.zxid

用来标识一次更新操作的提议ID，64位表示，高32位是Leader的轮次，从1开始，每换一个leader都会递增1，而低32位用来标记一次事务

##### 3.服务器状态

- LOOKING：不确定Leader状态，会发起Leader选举
- FOLLOWING：跟随者状态，表明当前服务器是follower状态
- LEADING：表示整个服务器是leader，它会维护与follower的心跳
- OBSERVING：观察者状态。表明当前服务器角色是Observer，与Folower唯一的不同在于不参与选举，也不参与集群写操作时的投票

**4、选票数据结构**

 每个服务器在进行领导选举时，会发送如下关键信息：

- **logicClock** 每个服务器会维护一个自增的整数，名为logicClock，它表示这是该服务器发起的第多少轮投票
- **state** 当前服务器的状态
- **self_id** 当前服务器的myid
- **self_zxid** 当前服务器上所保存的数据的最大zxid
- **vote_id** 被推举的服务器的myid
- **vote_zxid** 被推举的服务器上所保存的数据的最大zxid

### 投票流程

- 当开始投票时，每个服务器都会先把票投给自己，然后进行广播，

- 接下来接受外部投票
- 判断选举轮次，如果外部投票的轮次大于自己的轮次，说明自己的轮次已经落后，就会将自己的轮次更新为这个轮次，然后进行选票PK
- PK的规则是：比较自己推举的服务器的Zxid，也就是事务id，如果小的话，就会将票投给大的，并广播出去，如果相等，就会投给myid大的
- 如果有过半的服务器投给了某个服务器，投票结束，更换服务器的状态

> 每次某个FOLLOWER重启都会进行一次投票

## 使用Zookeeper来实现分布式的锁

zookeeper有持久型节点和非持久型节点，有可以细分为持久型顺序节点和非顺序节点，以此类推

而zookeeper可以用**非持久型节点**来实现分布式锁

##### 非公平锁的实现

> 在zookeeper当中，非公平锁指的是锁被释放后，参与排队获取这个锁的所有客户端都可以去竞争，这和多线程中的非公平锁是有点区别的

采用 **非持久型非顺序**节点来完成

- 多个客户端尝试在zookeeper中创建非持久型非顺序节点，肯定只会有一个创建成功，这个客户端就获得了锁
- 创建失败的客户端会在这个节点上注册一个Watch，一旦锁被释放，也就是节点被删除，那么那些客户端就会收到推送，再次进行抢占

##### 公平锁的实现

> 公平锁指的是获取锁失败的客户端按照顺序去获得锁

采用 **非持久型顺序节点** 来完成

- 多个客户端会尝试获得锁的节点下创建出多个顺序节点，当尝试获取锁时，判断自己的节点是不是最小的，如果是则获取到锁
- 如果获取锁失败，**就注册Watch在比自己小的节点上，不是全部**，所以当锁被释放时，只会有第一个排队的客户端收到Watch通知，其他不会
- 收到通知后，并不会立即进行锁的获取，而是判断一下自己的顺序是否最小，如果不是，就还是会注册一个Watch到第一个比自己小的节点上



## Zookeeper的Watch原理

- 对于创建一个zookeeper客户端时，会创建出两个线程，一个是用来连接服务器的contect线程，一个负责监听的listener线程
- 然后通过contect线程将监听事件发送给zookeeper服务器
- 服务器将这个监听事件注册到监听列表当中
- 当节点发生变化后，zookeeper服务器会将消息发送到listener线程当中
- listener线程调用precsss()方法进行处理