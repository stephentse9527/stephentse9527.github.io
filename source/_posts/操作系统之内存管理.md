---
title: 操作系统之内存管理
date: 2021-05-03 20:40:59
categories:
- 计算机基础
- 操作系统
---

## 逻辑地址和物理地址

在进程当中，地址是从0号单元开始编址的，这叫做进程的逻辑地址

而物理地址是指的内存中物理单元的位置，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存当中获取，而逻辑地址和物理地址的转换称为地址重定位

## 内存保护

系统需要保护用户进程不受其他用户进程的影响，采用基址寄存器和界地址寄存器来实现保护

基址寄存器保存的是进程最小的**物理地址**，界地址寄存器保存的是进程中最大的**逻辑地址**。当需要访问某个数据时，也就是在进程当中访问某个逻辑地址，先通过与界地址寄存器进行比较，如果大于则表示越界。

> 基址寄存器是用来进行 "+" 操作的，而界地址寄存器是用来进行合法检验的，如果目标逻辑地址小于界地址，那么就可用 基址 + 逻辑地址来定位物理地址

## 内存分配

> 为了同时将多个进程保留在内存中，如果对每个进程都申请连续的内存空间，那么就极有可能产生大量的内存碎片，导致即使拥有足够下一个进程所需的内存空间，也无法将这个进程加载进来。
>
> 无论是页式管理还是段式存储管理，都是为了增加内存的利用率，减少内存碎片，而之前的存储管理是固定分区方式

##### 页式存储管理

操作系统将主存分为大小相等且固定的块，作为主存的基本单位，而每个进程也是以块作为单位进行划分，进程在执行时，以块作为单位逐个申请空间，所以进程申请的空间在主存当中是可以不连续的。

块在进程当中被称为页，而在主存当中被称为页框，进程当中页会有自己的页号，从0开始，为了使得通过页找到主存当中的页框，使用的时页表来对页和页框做映射

而又可以根据是否要把所有的页面都装入内存才可以运行分为**基本分页存储**和**请求分页存储**

##### 段式存储管理

分页管理方式是从计算机的角度设计的，目的是增加内存利用率，减少内存碎片，而段式管理是根据用户进程中的自然段划分的，比如一个进程从有两个子进程，就可以划分为3个段。每个段从0开始编址，并分配一段连续的内存空间（段中要求连续，而段之间不要求连续），同样使用段表来对每个段进行段在内存空间的映射

##### 段页式存储管理

**页式管理能有效的提高内存利用率，而分段式管理能反映程序的逻辑结构**，将两种方式结合起来，就形成了段页式存储管理

进程的地址空间先根据程序的逻辑结构分成不同的段，每个段都有自己的段号，然后在段当中分成若干大小固定的页，而对于每个段或者是段中的页，管理和段式和页式没什么区别，每个段使用段表来进行段在主存的起始地址的映射，而段中的块则采用页表的形式来做页和页框的映射

> 所以段页式存储管理下，最多有一个段表，而页表可能有很多个

## 虚拟内存

##### 局部性原理

局部性原理表现在两个方面：

- 时间局部性：程序当中的指令在在某一时刻被执行后，在接下来的时间内可能会再次被执行，某个数据在被访问过后，接下来可能会再次被访问
- 空间局部性：某个内存单元在被访问后，它相邻的内存单元也可能会被访问

> 为什么呢？因为程序当中的指令是顺序存放，顺序执行的，而数据一般也是按照向量、数组、表的形式以聚簇的形式进行存储，所以访问可能会有关联性

所以基于局部性原理，在程序装入内存时，只将程序的一部分装入，其余留在外存当中，当访问的数据不在内存当中时，操作系统将该部分装入内存当中，这样系统好像就为用户进程提供了一个比实际内存大得多的存储空间，称为虚拟内存

## 虚拟内存技术的实现

虚拟内存技术允许将一个主页分多次调入内存，所以要求进程是按照离散的形式调入内存的，所以虚拟内存的实现有三种形式：

- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理

> [请求和基本管理](#页式存储管理)

而需要硬件支持：

- 页表或段表机制
- 中断机制，当用户程序访问的数据的部分没有装入内存中时，产生中断
- 地址变化机构，逻辑地址到物理地址的变换

##### 页表机制

![image-20210404171444423](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20210404171444423.png)

##### 缺页中断机构

当所访问的页面不在内存块中时，便会产生一个缺页中断，请求操作系统将所缺的页调入内存当中，如果内存中有空闲块，则分配一个块，将装入的页放在该块，如果没有空余的块，则要淘汰某块

##### 页面置换算法

- 最佳算法：淘汰的总是以后不再使用的页，但是无法预测，所以无法实现，是用来衡量其他算法的标准
- 先进先出页面置换算法：总是淘汰最先进入内存的页面，**而这个算法会出现所分配的块数越多产生缺页中断的次数不减反增的异常现象，叫做belady异常**
- 最近最久未使用LRU算法：选择最近最长时间未访问的页进行淘汰，通过页表中的访问字段来判断大小
- 时钟置换算法：使用使用位和修改位来标记一个页。当进行淘汰时，优先淘汰第一个遇到的未使用的，也未修改的页，如果没有，则淘汰第一个使用的，但未修改的页

##### 抖动

在页面置换过程中，如果换出的页马上又要装入内存，装入内存的页马上要换出内存，这种频繁的页面调度行为则被称为抖动

> 产生抖动原因：进程频繁访问的页面数大于系统可用的页框数，装入换出的页都是进程需要访问的页

##### 虚拟内存空间的大小由上面因素决定

- 虚拟内存的大小 <= 内存容量和外存容量之和，如果超过了这个容量，则没有相应的空间来供虚拟内存使用
- <= 计算机地址位数能容纳的最大容量，假设是32位，一个地址代表1B存储空间，那么虚存的大小就小于4GB (2^32B)