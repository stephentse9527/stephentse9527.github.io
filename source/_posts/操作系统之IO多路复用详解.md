---
title: 操作系统之IO多路复用详解
date: 2021-05-03 20:44:59
categories:
  - 计算机基础
  - 操作系统
---

### 用户空间与内核空间

操作系统为了保证内核安全，将内存空间分为两部分：用户空间和内核空间，用户的程序都运行在用户空间上，而对于管理系统的进程，内存，设备，文件等操作，都只能由运行在内核空间的核心进程来进行

### 文件描述符fd

文件描述符（File descriptor）是一个用于表述指向文件的引用的抽象化概念。

文件描述符在形式上是一个**非负整数**。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统

### 缓存 I/O

缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

**缓存 I/O 的缺点：**
数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。

### 从阻塞 I/O 到 I/O 多路复用

阻塞 I/O，是指进程发起调用后，会被挂起（阻塞），直到收到数据再返回。如果调用一直不返回，进程就会一直被挂起。因此，当使用阻塞 I/O 时，需要使用**多线程**来处理多个文件描述符。

多线程切换有一定的开销，因此引入非阻塞 I/O。非阻塞 I/O 不会将进程挂起，调用时会立即返回成功或错误，因此可以在**一个线程**里*轮询*多个文件描述符是否就绪。

但是非阻塞 I/O 的缺点是：每次发起系统调用，只能检查**一个**文件描述符是否就绪。当文件描述符很多时，系统调用的成本很高。

因此引入了 I/O 多路复用，可以**通过一次系统调用，检查多个文件描述符的状态**。这是 I/O 多路复用的主要优点，相比于非阻塞 I/O，在文件描述符较多的场景下，避免了频繁的用户态和内核态的切换，减少了系统调用的开销。

> I/O 多路复用相当于将「遍历所有文件描述符、通过非阻塞 I/O 查看其是否就绪」的过程从用户线程移到了内核中，由内核来负责轮询

### I/O 多路复用之select、poll、epoll详解

#### select

select函数将监视的文件描述符分为三类：readfds，writefds，errorfds，采用位图的形式，对于未就绪的文件描述符，使用0表示，而就绪则采用1表示。

调用select后，会顺序遍历文件描述符列表检查每个文件描述符是否就绪，如果每个文件描述符都未就绪，那么select就会阻塞timeout时长，再返回，这期间如果某个文件描述符发生可读事件，则select会将对应位置为1，并立即返回

select的缺点：

- 性能开销大：需要遍历传递进来的每个文件描述符，不管他们是否就绪
- 同时能够监听的文件描述符数量太少，受限于fd_set的大小

#### poll

poll和select的区别是：poll是采用链表的方式来存储文件描述符，没有最大的存储数量的限制

#### epoll

epoll是对select和poll的改进，避免了性能开销过大，和文件描述符数量少的两个缺点

epoll有以下三个特点：

- 使用红黑树存储文件描述符集合
- 使用队列存储就绪的文件描述符
- 每个文件描述符只需要在添加时传入一次，通过事件更改文件描述符状态

epoll使用三个函数来进行操作，分别是 `epoll_create`，`epoll_ctl ` 和 `epoll_wait`

##### epoll_create

`epoll_create` 会创建一个 `epoll` 实例，同时返回一个引用该实例的文件描述符。

返回的文件描述符仅仅指向对应的 `epoll` 实例，并不表示真实的磁盘文件节点。其他 API 如 `epoll_ctl`、`epoll_wait` 会使用这个文件描述符来操作相应的 `epoll` 实例。

当创建好 epoll 句柄后，它会占用一个 fd 值，在 linux 下查看 `/proc/进程id/fd/`，就能够看到这个 fd。所以在使用完 epoll 后，必须调用 `close(epfd)` 关闭对应的文件描述符，否则可能导致 fd 被耗尽。当指向同一个 `epoll` 实例的所有文件描述符都被关闭后，操作系统会销毁这个 `epoll` 实例

`epoll` 实例内部存储：

- 监听列表：所有要监听的文件描述符，使用红黑树
- 就绪列表：所有就绪的文件描述符，使用链表

##### epoll_ctl

`epoll_ctl` 会将文件描述符 `fd` 添加到 `epoll` 实例的监听列表里，同时为 `fd` 设置一个回调函数，并监听事件 `event`。当 `fd` 上发生相应事件时，会调用回调函数，将 `fd` 添加到 `epoll` 实例的就绪队列上

##### epoll_wait

这是 epoll 模型的主要函数，功能相当于 `select`

如果没有文件描述符就绪，即就绪队列为空，则epoll_wait会阻塞timeout秒，直到有文件描述符就绪，如果timeout为0，则立即返回

##### epoll的优点(面试可能会问)

- 避免了性能开销大：epoll_ctl中为每个文件描述符指定了回调函数，并在就绪时将器加入到就绪队列当中，使用不需要遍历每个文件描述符，只需要判断就绪队列列表是否为空即可，这样在没有描述符就绪时，epoll能更早的让出系统资源
- 而低于文件描述符少，select采用位图存储文件描述符，而epoll使用红黑树存储，数量较大

### 三者对比

- `select`：调用开销大（需要复制集合）；集合大小有限制；需要遍历整个集合找到就绪的描述符
- `poll`：poll 采用链表的方式存储文件描述符，没有最大存储数量的限制，其他方面和 select 没有区别
- `epoll`：调用开销小（不需要复制）；集合大小无限制；采用回调机制，不需要遍历整个集合

`select`、`poll` 都是在用户态维护文件描述符集合，因此每次需要将完整集合传给内核；`epoll` 由操作系统在内核中维护文件描述符集合，因此只需要在创建的时候传入文件描述符