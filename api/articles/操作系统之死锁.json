{"title":"操作系统之死锁","uid":"2ef40044afb1f095a6625b5d86ae265d","slug":"操作系统之死锁","date":"2021-05-03T20:43:12.000Z","updated":"2022-09-15T14:22:17.564Z","comments":true,"path":"api/articles/操作系统之死锁.json","keywords":null,"cover":[],"content":"<h2 id=\"死锁产生的条件\"><a href=\"#死锁产生的条件\" class=\"headerlink\" title=\"死锁产生的条件\"></a>死锁产生的条件</h2><ul>\n<li>互斥：一个临界资源只能同时被一个进程所占有</li>\n<li>不可抢占：一个进程获取的资源只能由这个线程主动释放，不能被抢占</li>\n<li>占有且等待：一个进程占有某些资源，并尝试去获取被其他进程占有的其他的资源</li>\n<li>循环等待：进程等待形成环形等待链，每个进程都占有着上一个进程想要获取的资源，并且等待着下一个进程占有的资源</li>\n</ul>\n<h2 id=\"怎么处理死锁？\"><a href=\"#怎么处理死锁？\" class=\"headerlink\" title=\"怎么处理死锁？\"></a>怎么处理死锁？</h2><p>死锁的处理主要分为 <strong>死锁的预防</strong>，<strong>死锁的避免</strong>，以及<strong>死锁的检测和解除</strong></p>\n<h5 id=\"死锁的预防\"><a href=\"#死锁的预防\" class=\"headerlink\" title=\"死锁的预防\"></a>死锁的预防</h5><blockquote>\n<p>死锁的预防是指破环死锁产生的四个必要条件的一个或多个</p>\n</blockquote>\n<ul>\n<li>破坏不可抢占模式，一个进程申请被其他进程占有的资源时，要先释放自己手上的资源，这也可以认为是资源可以被抢占了</li>\n<li>破坏占有且等待：系统在给进程分配资源时，直接把进程所需资源一次性分配给进程</li>\n<li>破坏循环等待：将临界资源进行标记，进程进行资源的申请只能按照标记的某个方向进行申请</li>\n</ul>\n<h5 id=\"死锁的避免\"><a href=\"#死锁的避免\" class=\"headerlink\" title=\"死锁的避免\"></a>死锁的避免</h5><p>前置知识：系统安全状态，是指系统能按照某种进程推进顺序来为每个进程分配所需的资源，直至满足每个进程对资源的最大需求，如果系统无法找到这样的序列，那么就说系统处于不安全状态</p>\n<p>而找出系统安全状态，是使用的银行家算法</p>\n<h5 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h5><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/image-20210404130747924.png\" class=\"\" title=\"image-20210404130747924\">\n\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/image-20210404130812795.png\" class=\"\" title=\"image-20210404130812795\">\n\n<img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%AD%BB%E9%94%81/image-20210404130827919.png\" class=\"\" title=\"image-20210404130827919\">\n\n<h5 id=\"死锁的检测\"><a href=\"#死锁的检测\" class=\"headerlink\" title=\"死锁的检测\"></a>死锁的检测</h5><p>死锁的检测是指将系统资源和进程申请资源的关系画成 <strong>资源分配图</strong>，然后再进行资源分配图的简化，如果简化完成后资源分配图上还剩余线程，说明产生了死锁</p>\n<p><strong>死锁的解除</strong></p>\n<p>可以不使用死锁的预防和避免，允许死锁的产生，直到产生死锁后进行死锁的解除，主要方法又：</p>\n<ul>\n<li>资源剥夺法：挂起死锁进程，并抢占它的资源，分配给其他死锁进程</li>\n<li>撤销进程法：强制撤销部分或者是全部进程。</li>\n<li>进程回退法：让一个或者多个</li>\n</ul>\n","feature":null,"text":"死锁产生的条件 互斥：一个临界资源只能同时被一个进程所占有 不可抢占：一个进程获取的资源只能由这个线程主动释放，不能被抢占 占有且等待：一个进程占有某些资源，并尝试去获取被其他进程占有的其他的资源 循环等待：进程等待形成环形等待链，每个进程都占有着上一个进程想要获取的资源，并且等...","link":"","photos":[],"count_time":{"symbolsCount":682,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","count":4,"path":"api/tags/计算机基础.json"},{"name":"操作系统","slug":"操作系统","count":3,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">死锁产生的条件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%EF%BC%9F\"><span class=\"toc-text\">怎么处理死锁？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2\"><span class=\"toc-text\">死锁的预防</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D\"><span class=\"toc-text\">死锁的避免</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">银行家算法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B\"><span class=\"toc-text\">死锁的检测</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"操作系统之IO多路复用详解","uid":"6cd30b54600ff936f0e357293094df28","slug":"操作系统之IO多路复用详解","date":"2021-05-03T20:44:59.000Z","updated":"2022-09-15T14:22:17.560Z","comments":true,"path":"api/articles/操作系统之IO多路复用详解.json","keywords":null,"cover":null,"text":"用户空间与内核空间操作系统为了保证内核安全，将内存空间分为两部分：用户空间和内核空间，用户的程序都运行在用户空间上，而对于管理系统的进程，内存，设备，文件等操作，都只能由运行在内核空间的核心进程来进行 文件描述符fd文件描述符（File descriptor）是一个用于表述指向文...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","count":4,"path":"api/tags/计算机基础.json"},{"name":"操作系统","slug":"操作系统","count":3,"path":"api/tags/操作系统.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"操作系统之内存管理","uid":"c48274d266bd8fce81f6183578ffb524","slug":"操作系统之内存管理","date":"2021-05-03T20:40:59.000Z","updated":"2022-09-15T14:22:17.560Z","comments":true,"path":"api/articles/操作系统之内存管理.json","keywords":null,"cover":[],"text":"逻辑地址和物理地址在进程当中，地址是从0号单元开始编址的，这叫做进程的逻辑地址 而物理地址是指的内存中物理单元的位置，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存当中获取，而逻辑地址和物理地址的转换称为地址重定位 内存保护系统需要保护用户进程不受其他用户进程的影响，...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","count":4,"path":"api/tags/计算机基础.json"},{"name":"操作系统","slug":"操作系统","count":3,"path":"api/tags/操作系统.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}