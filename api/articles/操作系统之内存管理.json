{"title":"操作系统之内存管理","uid":"c48274d266bd8fce81f6183578ffb524","slug":"操作系统之内存管理","date":"2021-05-03T20:40:59.000Z","updated":"2022-09-15T14:22:17.560Z","comments":true,"path":"api/articles/操作系统之内存管理.json","keywords":null,"cover":[],"content":"<h2 id=\"逻辑地址和物理地址\"><a href=\"#逻辑地址和物理地址\" class=\"headerlink\" title=\"逻辑地址和物理地址\"></a>逻辑地址和物理地址</h2><p>在进程当中，地址是从0号单元开始编址的，这叫做进程的逻辑地址</p>\n<p>而物理地址是指的内存中物理单元的位置，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存当中获取，而逻辑地址和物理地址的转换称为地址重定位</p>\n<h2 id=\"内存保护\"><a href=\"#内存保护\" class=\"headerlink\" title=\"内存保护\"></a>内存保护</h2><p>系统需要保护用户进程不受其他用户进程的影响，采用基址寄存器和界地址寄存器来实现保护</p>\n<p>基址寄存器保存的是进程最小的<strong>物理地址</strong>，界地址寄存器保存的是进程中最大的<strong>逻辑地址</strong>。当需要访问某个数据时，也就是在进程当中访问某个逻辑地址，先通过与界地址寄存器进行比较，如果大于则表示越界。</p>\n<blockquote>\n<p>基址寄存器是用来进行 “+” 操作的，而界地址寄存器是用来进行合法检验的，如果目标逻辑地址小于界地址，那么就可用 基址 + 逻辑地址来定位物理地址</p>\n</blockquote>\n<h2 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h2><blockquote>\n<p>为了同时将多个进程保留在内存中，如果对每个进程都申请连续的内存空间，那么就极有可能产生大量的内存碎片，导致即使拥有足够下一个进程所需的内存空间，也无法将这个进程加载进来。</p>\n<p>无论是页式管理还是段式存储管理，都是为了增加内存的利用率，减少内存碎片，而之前的存储管理是固定分区方式</p>\n</blockquote>\n<h5 id=\"页式存储管理\"><a href=\"#页式存储管理\" class=\"headerlink\" title=\"页式存储管理\"></a>页式存储管理</h5><p>操作系统将主存分为大小相等且固定的块，作为主存的基本单位，而每个进程也是以块作为单位进行划分，进程在执行时，以块作为单位逐个申请空间，所以进程申请的空间在主存当中是可以不连续的。</p>\n<p>块在进程当中被称为页，而在主存当中被称为页框，进程当中页会有自己的页号，从0开始，为了使得通过页找到主存当中的页框，使用的时页表来对页和页框做映射</p>\n<p>而又可以根据是否要把所有的页面都装入内存才可以运行分为<strong>基本分页存储</strong>和<strong>请求分页存储</strong></p>\n<h5 id=\"段式存储管理\"><a href=\"#段式存储管理\" class=\"headerlink\" title=\"段式存储管理\"></a>段式存储管理</h5><p>分页管理方式是从计算机的角度设计的，目的是增加内存利用率，减少内存碎片，而段式管理是根据用户进程中的自然段划分的，比如一个进程从有两个子进程，就可以划分为3个段。每个段从0开始编址，并分配一段连续的内存空间（段中要求连续，而段之间不要求连续），同样使用段表来对每个段进行段在内存空间的映射</p>\n<h5 id=\"段页式存储管理\"><a href=\"#段页式存储管理\" class=\"headerlink\" title=\"段页式存储管理\"></a>段页式存储管理</h5><p><strong>页式管理能有效的提高内存利用率，而分段式管理能反映程序的逻辑结构</strong>，将两种方式结合起来，就形成了段页式存储管理</p>\n<p>进程的地址空间先根据程序的逻辑结构分成不同的段，每个段都有自己的段号，然后在段当中分成若干大小固定的页，而对于每个段或者是段中的页，管理和段式和页式没什么区别，每个段使用段表来进行段在主存的起始地址的映射，而段中的块则采用页表的形式来做页和页框的映射</p>\n<blockquote>\n<p>所以段页式存储管理下，最多有一个段表，而页表可能有很多个</p>\n</blockquote>\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><h5 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h5><p>局部性原理表现在两个方面：</p>\n<ul>\n<li>时间局部性：程序当中的指令在在某一时刻被执行后，在接下来的时间内可能会再次被执行，某个数据在被访问过后，接下来可能会再次被访问</li>\n<li>空间局部性：某个内存单元在被访问后，它相邻的内存单元也可能会被访问</li>\n</ul>\n<blockquote>\n<p>为什么呢？因为程序当中的指令是顺序存放，顺序执行的，而数据一般也是按照向量、数组、表的形式以聚簇的形式进行存储，所以访问可能会有关联性</p>\n</blockquote>\n<p>所以基于局部性原理，在程序装入内存时，只将程序的一部分装入，其余留在外存当中，当访问的数据不在内存当中时，操作系统将该部分装入内存当中，这样系统好像就为用户进程提供了一个比实际内存大得多的存储空间，称为虚拟内存</p>\n<h2 id=\"虚拟内存技术的实现\"><a href=\"#虚拟内存技术的实现\" class=\"headerlink\" title=\"虚拟内存技术的实现\"></a>虚拟内存技术的实现</h2><p>虚拟内存技术允许将一个主页分多次调入内存，所以要求进程是按照离散的形式调入内存的，所以虚拟内存的实现有三种形式：</p>\n<ul>\n<li>请求分页存储管理</li>\n<li>请求分段存储管理</li>\n<li>请求段页式存储管理</li>\n</ul>\n<blockquote>\n<p><a href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\">请求和基本管理</a></p>\n</blockquote>\n<p>而需要硬件支持：</p>\n<ul>\n<li>页表或段表机制</li>\n<li>中断机制，当用户程序访问的数据的部分没有装入内存中时，产生中断</li>\n<li>地址变化机构，逻辑地址到物理地址的变换</li>\n</ul>\n<h5 id=\"页表机制\"><a href=\"#页表机制\" class=\"headerlink\" title=\"页表机制\"></a>页表机制</h5><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20210404171444423.png\" class=\"\" title=\"image-20210404171444423\">\n\n<h5 id=\"缺页中断机构\"><a href=\"#缺页中断机构\" class=\"headerlink\" title=\"缺页中断机构\"></a>缺页中断机构</h5><p>当所访问的页面不在内存块中时，便会产生一个缺页中断，请求操作系统将所缺的页调入内存当中，如果内存中有空闲块，则分配一个块，将装入的页放在该块，如果没有空余的块，则要淘汰某块</p>\n<h5 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h5><ul>\n<li>最佳算法：淘汰的总是以后不再使用的页，但是无法预测，所以无法实现，是用来衡量其他算法的标准</li>\n<li>先进先出页面置换算法：总是淘汰最先进入内存的页面，<strong>而这个算法会出现所分配的块数越多产生缺页中断的次数不减反增的异常现象，叫做belady异常</strong></li>\n<li>最近最久未使用LRU算法：选择最近最长时间未访问的页进行淘汰，通过页表中的访问字段来判断大小</li>\n<li>时钟置换算法：使用使用位和修改位来标记一个页。当进行淘汰时，优先淘汰第一个遇到的未使用的，也未修改的页，如果没有，则淘汰第一个使用的，但未修改的页</li>\n</ul>\n<h5 id=\"抖动\"><a href=\"#抖动\" class=\"headerlink\" title=\"抖动\"></a>抖动</h5><p>在页面置换过程中，如果换出的页马上又要装入内存，装入内存的页马上要换出内存，这种频繁的页面调度行为则被称为抖动</p>\n<blockquote>\n<p>产生抖动原因：进程频繁访问的页面数大于系统可用的页框数，装入换出的页都是进程需要访问的页</p>\n</blockquote>\n<h5 id=\"虚拟内存空间的大小由上面因素决定\"><a href=\"#虚拟内存空间的大小由上面因素决定\" class=\"headerlink\" title=\"虚拟内存空间的大小由上面因素决定\"></a>虚拟内存空间的大小由上面因素决定</h5><ul>\n<li>虚拟内存的大小 &lt;= 内存容量和外存容量之和，如果超过了这个容量，则没有相应的空间来供虚拟内存使用</li>\n<li>&lt;= 计算机地址位数能容纳的最大容量，假设是32位，一个地址代表1B存储空间，那么虚存的大小就小于4GB (2^32B)</li>\n</ul>\n","feature":null,"text":"逻辑地址和物理地址在进程当中，地址是从0号单元开始编址的，这叫做进程的逻辑地址 而物理地址是指的内存中物理单元的位置，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存当中获取，而逻辑地址和物理地址的转换称为地址重定位 内存保护系统需要保护用户进程不受其他用户进程的影响，...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","count":4,"path":"api/tags/计算机基础.json"},{"name":"操作系统","slug":"操作系统","count":3,"path":"api/tags/操作系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">逻辑地址和物理地址</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">内存保护</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D\"><span class=\"toc-text\">内存分配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">页式存储管理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">段式存储管理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">段页式存储管理</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\"><span class=\"toc-text\">虚拟内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">局部性原理</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">虚拟内存技术的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">页表机制</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84\"><span class=\"toc-text\">缺页中断机构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">页面置换算法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%8A%96%E5%8A%A8\"><span class=\"toc-text\">抖动</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%94%B1%E4%B8%8A%E9%9D%A2%E5%9B%A0%E7%B4%A0%E5%86%B3%E5%AE%9A\"><span class=\"toc-text\">虚拟内存空间的大小由上面因素决定</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"操作系统之死锁","uid":"2ef40044afb1f095a6625b5d86ae265d","slug":"操作系统之死锁","date":"2021-05-03T20:43:12.000Z","updated":"2022-09-15T14:22:17.564Z","comments":true,"path":"api/articles/操作系统之死锁.json","keywords":null,"cover":[],"text":"死锁产生的条件 互斥：一个临界资源只能同时被一个进程所占有 不可抢占：一个进程获取的资源只能由这个线程主动释放，不能被抢占 占有且等待：一个进程占有某些资源，并尝试去获取被其他进程占有的其他的资源 循环等待：进程等待形成环形等待链，每个进程都占有着上一个进程想要获取的资源，并且等...","link":"","photos":[],"count_time":{"symbolsCount":682,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","count":4,"path":"api/tags/计算机基础.json"},{"name":"操作系统","slug":"操作系统","count":3,"path":"api/tags/操作系统.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Zookeeper工作原理和机制","uid":"26f886a7c89a2304aec3bf49d8ad4b85","slug":"Zookeeper工作原理和机制","date":"2021-05-03T20:37:38.000Z","updated":"2022-09-15T14:22:17.540Z","comments":true,"path":"api/articles/Zookeeper工作原理和机制.json","keywords":null,"cover":[],"text":"Zookeeper工作机制是一个分布式服务管理框架，负责存储和管理数据，然后接受观察者的注册，一旦这些数据发生变化，zookeeper就负责通知这些观察者做出相应的反应 Zookeeper服务器角色一般zookeeper都是以集群的形式存在的，是一个基于主从复制的高可用集群，每个...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"中间件","slug":"中间件","count":5,"path":"api/tags/中间件.json"},{"name":"底层原理","slug":"底层原理","count":4,"path":"api/tags/底层原理.json"},{"name":"Zookeeper","slug":"Zookeeper","count":1,"path":"api/tags/Zookeeper.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}