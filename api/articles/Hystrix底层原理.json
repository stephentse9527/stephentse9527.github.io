{"title":"Hystrix底层原理","uid":"66fbda97c6061d29db33ae44cd19310f","slug":"Hystrix底层原理","date":"2021-05-03T20:31:56.000Z","updated":"2022-09-15T14:22:17.520Z","comments":true,"path":"api/articles/Hystrix底层原理.json","keywords":null,"cover":[],"content":"<h3 id=\"Hystrix-是什么？\"><a href=\"#Hystrix-是什么？\" class=\"headerlink\" title=\"Hystrix 是什么？\"></a>Hystrix 是什么？</h3><p>在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是<strong>依赖服务</strong>，有的时候某些依赖服务出现故障也是很正常的。</p>\n<h3 id=\"Hystrix可以提供那些功能\"><a href=\"#Hystrix可以提供那些功能\" class=\"headerlink\" title=\"Hystrix可以提供那些功能\"></a>Hystrix可以提供那些功能</h3><p>Hystrix可以提供：</p>\n<ul>\n<li>服务熔断</li>\n<li>服务降级</li>\n<li>服务限流</li>\n</ul>\n<h3 id=\"Hystrix-更加细节的设计原则\"><a href=\"#Hystrix-更加细节的设计原则\" class=\"headerlink\" title=\"Hystrix 更加细节的设计原则\"></a>Hystrix 更加细节的设计原则</h3><ul>\n<li>阻止任何一个依赖服务耗尽所有的资源，比如 tomcat 中的所有线程资源。</li>\n<li>避免请求排队和积压，采用限流和 <code>fail fast</code> 来控制故障。</li>\n<li>提供 fallback 降级机制来应对故障。</li>\n<li>使用资源隔离技术，比如 <code>bulkhead</code>（舱壁隔离技术）、<code>swimlane</code>（泳道技术）、<code>circuit breaker</code>（断路技术）来限制任何一个依赖服务的故障的影响。</li>\n</ul>\n<h3 id=\"HystrixCommand的调用方法\"><a href=\"#HystrixCommand的调用方法\" class=\"headerlink\" title=\"HystrixCommand的调用方法\"></a>HystrixCommand的调用方法</h3><ul>\n<li><strong>execute</strong>：同步堵塞，调用了queue().get()方法，execute()执行完后，会创建一个新线程运行run()；</li>\n<li><strong>queue</strong>：异步非堵塞，它调用了toObservable().toBlocking().toFuture()方法，queue()执行完后，会创建一个新线程运行run()。Future.get()是堵塞的，它等待run()运行完才返回结果；</li>\n<li><strong>observe()</strong> ：异步热响应调用，它调用了toObservable().subscribe(subject)方法，observe()执行完后，会创建一个新线程运行run()。toBlocking().single()是堵塞的，需要等run()运行完才返回结果；</li>\n<li>**toObservable()**：异步的冷响应调用，该方法不会主动创建线程运行run()，只有当调用了toBlocking().single()或subscribe()时，才会去创建线程运行run()。</li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><p>Hystrix 实现资源隔离，主要有两种技术：</p>\n<ul>\n<li><p>线程池</p>\n<ul>\n<li><p><strong>第三方客户端（执行Hystrix的run()方法）会在单独的线程执行</strong>，会与调用的该任务的线程进行隔离，以此来防止调用者调用依赖所消耗的时间过长而阻塞调用者的线程。</p>\n<p>使用线程隔离的好处：</p>\n<ul>\n<li>应用程序可以不受失控的第三方客户端的威胁，如果第三方客户端出现问题，可以通过降级来隔离依赖。</li>\n<li>当失败的客户端服务恢复时，线程池将会被清除，应用程序也会恢复，而不至于使整个Tomcat容器出现故障。</li>\n<li>如果一个客户端库的配置错误，线程池可以很快的感知这一错误（通过增加错误比例，延迟，超时，拒绝等），并可以在不影响应用程序的功能情况下来处理这些问题（可以通过动态配置来进行实时的改变）。</li>\n<li>如果一个客户端服务的性能变差，可以通过改变线程池的指标（错误、延迟、超时、拒绝）来进行属性的调整，并且这些调整可以不影响其他的客户端请求。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>信号量</p>\n<ul>\n<li>信号隔离是通过限制依赖服务的并发请求数，来控制隔离开关。信号隔离方式下，<strong>业务请求线程和执行依赖服务的线程是同一个线程</strong>（例如Tomcat容器线程）</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>默认情况下，Hystrix 使用线程池模式</p>\n</blockquote>\n<h3 id=\"线程池与信号量区别\"><a href=\"#线程池与信号量区别\" class=\"headerlink\" title=\"线程池与信号量区别\"></a>线程池与信号量区别</h3><p>线程池：使用的是Hystrix内部维护的线程池，每一个依赖服务都会拥有自己的小线程池</p>\n<p>信号量隔离：是使用发起请求的线程去调用这个依赖服务，它只是一道关卡，信号量有多少，就允许多少个tomcat线程通过，然后执行</p>\n<img src=\"/post/Hystrix%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210306220714378.png\" class=\"\" title=\"image-20210306220714378\">\n\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li><strong>线程池技术</strong>，适合绝大多数场景，比如说我们对依赖服务的网络请求的调用和访问、需要对调用的 timeout 进行控制（捕捉 timeout 超时异常）。</li>\n<li><strong>信号量技术</strong>，适合说你的访问不是对外部依赖的访问，而是对内部的一些比较复杂的业务逻辑的访问，并且系统内部的代码，其实不涉及任何的网络请求，那么只要做信号量的普通限流就可以了，因为不需要去捕获 timeout 类似的问题。</li>\n</ul>\n<h2 id=\"Hystrix-隔离策略细粒度控制\"><a href=\"#Hystrix-隔离策略细粒度控制\" class=\"headerlink\" title=\"Hystrix 隔离策略细粒度控制\"></a>Hystrix 隔离策略细粒度控制</h2><ul>\n<li><strong>command key</strong> ：代表了一类 command，一般来说，代表了下游依赖服务的某个接口。</li>\n<li><strong>command group</strong> ，代表了某一个下游依赖服务，这是很合理的，一个依赖服务可能会暴露出来多个接口，每个接口就是一个 command key。command group 在逻辑上对一堆 command key 的调用次数、成功次数、timeout 次数、失败次数等进行统计，可以看到某一个服务整体的一些访问情况。<strong>一般来说，推荐根据一个服务区划分出一个线程池，command key 默认都是属于同一个线程池的。</strong></li>\n<li><strong>command thread pool</strong>：代表了每个command key的线程池，默认大小为10</li>\n<li><strong>coreSize</strong>：设置线程池的大小，默认是 10。一般来说，用这个默认的 10 个线程大小就够了</li>\n<li><strong>queueSizeRejectionThreshold</strong>：控制queue满了之后拒绝的阈值，和最大队列数量(maxQueueSize)不是一个意思，默认为 5</li>\n<li>查看默认值的位置：在HystrixThreadPoolProperties类中查看</li>\n</ul>\n<blockquote>\n<p>说白点，就是说如果你的 command key 要用自己的线程池，可以定义自己的 thread pool key，就 ok 了。</p>\n</blockquote>\n<h3 id=\"Hystrix-执行时内部原理\"><a href=\"#Hystrix-执行时内部原理\" class=\"headerlink\" title=\"Hystrix 执行时内部原理\"></a>Hystrix 执行时内部原理</h3><img src=\"/post/Hystrix%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/new-hystrix-process.jpg\" class=\"\" title=\"new-hystrix-process\">\n\n<ul>\n<li><h5 id=\"1-创建-command\"><a href=\"#1-创建-command\" class=\"headerlink\" title=\"1.创建 command\"></a>1.创建 command</h5></li>\n<li><h5 id=\"2-调用-command-执行方法\"><a href=\"#2-调用-command-执行方法\" class=\"headerlink\" title=\"2.调用 command 执行方法\"></a>2.调用 command 执行方法</h5><p>要执行 command，可以在 4 个方法中选择其中的一个：execute()、queue()、observe()、toObservable()。</p>\n</li>\n<li><h5 id=\"3-检查是否开启缓存（不太常用）\"><a href=\"#3-检查是否开启缓存（不太常用）\" class=\"headerlink\" title=\"3.检查是否开启缓存（不太常用）\"></a>3.检查是否开启缓存（不太常用）</h5><p>如果这个 command 开启了请求缓存 Request Cache，而且这个调用的结果在缓存中存在，那么直接从缓存中返回结果。否则，继续往后的步骤。</p>\n</li>\n<li><h5 id=\"4-检查是否开启了断路器\"><a href=\"#4-检查是否开启了断路器\" class=\"headerlink\" title=\"4.检查是否开启了断路器\"></a>4.检查是否开启了断路器</h5><p>检查这个 command 对应的依赖服务是否开启了断路器。如果断路器被打开了，那么 Hystrix 就不会执行这个 command，而是直接去执行 fallback 降级机制，返回降级结果。</p>\n</li>\n<li><h5 id=\"5-检查线程池-队列-信号量是否已满\"><a href=\"#5-检查线程池-队列-信号量是否已满\" class=\"headerlink\" title=\"5.检查线程池/队列/信号量是否已满\"></a>5.检查线程池/队列/信号量是否已满</h5><p>如果这个 command 线程池和队列已满，或者 semaphore 信号量已满，那么也不会执行 command，而是直接去调用 fallback 降级机制</p>\n</li>\n<li><h5 id=\"6-执行-command\"><a href=\"#6-执行-command\" class=\"headerlink\" title=\"6.执行 command\"></a>6.执行 command</h5><p>调用 HystrixObservableCommand 对象的 construct() 方法，或者 HystrixCommand 的 run() 方法来实际执行这个 command。</p>\n<p>如果是采用线程池方式，并且 HystrixCommand.run() 或者 HystrixObservableCommand.construct() 的执行时间超过了 timeout 时长的话，那么 command 所在的线程会抛出一个 TimeoutException，这时会执行 fallback 降级机制，不会去管 run() 或 construct() 返回的值了。另一种情况，如果 command 执行出错抛出了其它异常，那么也会走 fallback 降级。这两种情况下，Hystrix 都会发送异常事件给断路器统计</p>\n</li>\n<li><h5 id=\"7-断路健康检查\"><a href=\"#7-断路健康检查\" class=\"headerlink\" title=\"7.断路健康检查\"></a>7.断路健康检查</h5><p>Hystrix 会把每一个依赖服务的调用成功、失败、Reject、Timeout 等事件发送给 circuit breaker 断路器。断路器就会对这些事件的次数进行统计，根据异常事件发生的比例来决定是否要进行断路（熔断）。如果打开了断路器，那么在接下来一段时间内，会直接断路，返回降级结果。</p>\n<p>如果在之后，断路器尝试执行 command，调用没有出错，返回了正常结果，那么 Hystrix 就会把断路器关闭。</p>\n</li>\n<li><h5 id=\"8-调用-fallback-降级机制\"><a href=\"#8-调用-fallback-降级机制\" class=\"headerlink\" title=\"8.调用 fallback 降级机制\"></a>8.调用 fallback 降级机制</h5><p>在以下几种情况中，Hystrix 会调用 fallback 降级机制。</p>\n<ul>\n<li>断路器处于打开状态；</li>\n<li>线程池/队列/semaphore 满了；</li>\n<li>command 执行超时；</li>\n<li>run() 或者 construct() 抛出异常。</li>\n</ul>\n<p>不同的 command 执行方式，其 fallback 为空或者异常时的返回结果不同。</p>\n<ul>\n<li>对于 execute()，直接抛出异常。</li>\n<li>对于 queue()，返回一个 Future，调用 get() 时抛出异常</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"深入-Hystrix-断路器执行原理\"><a href=\"#深入-Hystrix-断路器执行原理\" class=\"headerlink\" title=\"深入 Hystrix 断路器执行原理\"></a>深入 Hystrix 断路器执行原理</h3><p>Hystrix 断路器有三种状态</p>\n<ul>\n<li>关闭（Closed）：调用依赖服务的请求正常通过</li>\n<li>打开（Open）：阻断对依赖服务的请求调用，直接走FallBack逻辑</li>\n<li>半开（Half-Open）：</li>\n</ul>\n<p>状态转换关系如下：</p>\n<img src=\"/post/Hystrix%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20210306231414813.png\" class=\"\" title=\"image-20210306231414813\">\n\n<p>运行机制：在一次统计时间的 滑动窗口（默认10秒） 中，最少有20次请求通过断路器，且异常比例超过50%，就会进入打开状态，在打开断路器后，接下来的3000毫秒都不会去d请求依赖服务，而是直接走的fallBack机制</p>\n<p>3000毫秒后，会进入半开状态，新的请求依赖服务会被执行，如果执行成功，就进入关闭状态，如果失败，则再次进入打开状态</p>\n<h3 id=\"两种最经典的降级机制\"><a href=\"#两种最经典的降级机制\" class=\"headerlink\" title=\"两种最经典的降级机制\"></a>两种最经典的降级机制</h3><ul>\n<li>纯内存数据<br>在降级逻辑中，你可以在内存中维护一个 ehcache，作为一个纯内存的基于 LRU 自动清理的缓存，让数据放在缓存内。如果说外部依赖有异常，fallback 这里直接尝试从 ehcache 中获取数据。</li>\n<li>默认值<br>fallback 降级逻辑中，也可以直接返回一个默认值。</li>\n</ul>\n","feature":null,"text":"Hystrix 是什么？在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是依赖服务，有的时候某些依赖服务出现故障也是很正常的。 Hystrix可以提供那些功能Hystrix可以提供： 服务熔断 服务降级 服务限流 Hystrix 更加细节的设计原则 阻止任何一...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"中间件","slug":"中间件","count":5,"path":"api/tags/中间件.json"},{"name":"底层原理","slug":"底层原理","count":4,"path":"api/tags/底层原理.json"},{"name":"Hystrix","slug":"Hystrix","count":1,"path":"api/tags/Hystrix.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hystrix-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">Hystrix 是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hystrix%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E9%82%A3%E4%BA%9B%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">Hystrix可以提供那些功能</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hystrix-%E6%9B%B4%E5%8A%A0%E7%BB%86%E8%8A%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">Hystrix 更加细节的设计原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HystrixCommand%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">HystrixCommand的调用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">线程池与信号量区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hystrix-%E9%9A%94%E7%A6%BB%E7%AD%96%E7%95%A5%E7%BB%86%E7%B2%92%E5%BA%A6%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">Hystrix 隔离策略细粒度控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hystrix-%E6%89%A7%E8%A1%8C%E6%97%B6%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Hystrix 执行时内部原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA-command\"><span class=\"toc-text\">1.创建 command</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%B0%83%E7%94%A8-command-%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.调用 command 执行方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E7%BC%93%E5%AD%98%EF%BC%88%E4%B8%8D%E5%A4%AA%E5%B8%B8%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">3.检查是否开启缓存（不太常用）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E4%BA%86%E6%96%AD%E8%B7%AF%E5%99%A8\"><span class=\"toc-text\">4.检查是否开启了断路器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E6%A3%80%E6%9F%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E9%98%9F%E5%88%97-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%98%AF%E5%90%A6%E5%B7%B2%E6%BB%A1\"><span class=\"toc-text\">5.检查线程池&#x2F;队列&#x2F;信号量是否已满</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-%E6%89%A7%E8%A1%8C-command\"><span class=\"toc-text\">6.执行 command</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-%E6%96%AD%E8%B7%AF%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">7.断路健康检查</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-%E8%B0%83%E7%94%A8-fallback-%E9%99%8D%E7%BA%A7%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">8.调用 fallback 降级机制</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E5%85%A5-Hystrix-%E6%96%AD%E8%B7%AF%E5%99%A8%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">深入 Hystrix 断路器执行原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E7%A7%8D%E6%9C%80%E7%BB%8F%E5%85%B8%E7%9A%84%E9%99%8D%E7%BA%A7%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">两种最经典的降级机制</span></a></li></ol>","author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Zookeeper工作原理和机制","uid":"26f886a7c89a2304aec3bf49d8ad4b85","slug":"Zookeeper工作原理和机制","date":"2021-05-03T20:37:38.000Z","updated":"2022-09-15T14:22:17.540Z","comments":true,"path":"api/articles/Zookeeper工作原理和机制.json","keywords":null,"cover":[],"text":"Zookeeper工作机制是一个分布式服务管理框架，负责存储和管理数据，然后接受观察者的注册，一旦这些数据发生变化，zookeeper就负责通知这些观察者做出相应的反应 Zookeeper服务器角色一般zookeeper都是以集群的形式存在的，是一个基于主从复制的高可用集群，每个...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"中间件","slug":"中间件","count":5,"path":"api/tags/中间件.json"},{"name":"底层原理","slug":"底层原理","count":4,"path":"api/tags/底层原理.json"},{"name":"Zookeeper","slug":"Zookeeper","count":1,"path":"api/tags/Zookeeper.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"LinkedHashMap源码分析","uid":"3864b9afa9fa3172cb932c409fc2806d","slug":"LinkedHashMap源码分析","date":"2021-05-03T20:28:47.000Z","updated":"2022-09-15T14:22:17.520Z","comments":true,"path":"api/articles/LinkedHashMap源码分析.json","keywords":null,"cover":null,"text":"LinkedHashMap源码分析LinkedHashMap 继承于 HashMap，用来存储数据的Entry也是继承HashMap的Node节点，多了两个引用before，after，用来把节点变成双向链表 static class Entry&lt;K,V> extends ...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"源码分析","slug":"源码分析","count":5,"path":"api/tags/源码分析.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}