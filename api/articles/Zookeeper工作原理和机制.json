{"title":"Zookeeper工作原理和机制","uid":"26f886a7c89a2304aec3bf49d8ad4b85","slug":"Zookeeper工作原理和机制","date":"2021-05-03T20:37:38.000Z","updated":"2022-09-15T14:22:17.540Z","comments":true,"path":"api/articles/Zookeeper工作原理和机制.json","keywords":null,"cover":[],"content":"<h1 id=\"Zookeeper工作机制\"><a href=\"#Zookeeper工作机制\" class=\"headerlink\" title=\"Zookeeper工作机制\"></a>Zookeeper工作机制</h1><p>是一个分布式服务管理框架，负责存储和管理数据，然后接受观察者的注册，一旦这些数据发生变化，zookeeper就负责通知这些观察者做出相应的反应</p>\n<h2 id=\"Zookeeper服务器角色\"><a href=\"#Zookeeper服务器角色\" class=\"headerlink\" title=\"Zookeeper服务器角色\"></a>Zookeeper服务器角色</h2><p>一般zookeeper都是以集群的形式存在的，是一个基于主从复制的高可用集群，每个服务器承担三个角色的一种：</p>\n<ul>\n<li><strong>Leader：</strong>一个集群只有有一个Leader，他会发起并维护各Follwer和Observer间的心跳，所有的写操作都会Leader来进行完成并将写操作广播给其他Follwer</li>\n<li><strong>Follower：</strong>可同时存在多个，它会响应Leader的心跳，它可以直接处理并返回客户端的读请求，但如果是写请求，会将请求转发给Leader处理，并负责对Leader的写请求进行投票</li>\n<li><strong>Observer：</strong>和Follower类似，但是无投票权</li>\n</ul>\n<img src=\"/post/Zookeeper%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%9C%BA%E5%88%B6/image-20210407141352648.png\" class=\"\" title=\"image-20210407141352648\">\n\n<h2 id=\"Zookeeper怎么保证读写操作的一致性和可用性？\"><a href=\"#Zookeeper怎么保证读写操作的一致性和可用性？\" class=\"headerlink\" title=\"Zookeeper怎么保证读写操作的一致性和可用性？\"></a>Zookeeper怎么保证读写操作的一致性和可用性？</h2><p>使用的是原子广播(ZAB)来实现，根据ZAB协议，所有的写操作都需要通过 Leader 来完成，Leader 写入本地日志后再复制到所有的Follower节点上，而一旦Leader节点无法工作，ZAB协议能够自动从Follower节点中重新选出一个合适的替代者</p>\n<h2 id=\"写Leader\"><a href=\"#写Leader\" class=\"headerlink\" title=\"写Leader\"></a>写Leader</h2><img src=\"/post/Zookeeper%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%9C%BA%E5%88%B6/image-20210407155421726.png\" class=\"\" title=\"image-20210407155421726\">\n\n<p>如果通过Leader进行写操作，会进行下列步骤：</p>\n<ul>\n<li>客户端向Leader发送写请求</li>\n<li>Leader将写请求以<strong>提议</strong>的形式发送给所有的Follower并等待确认</li>\n<li>Follower收到Leader的提议后返回确认</li>\n<li>Leader得到<strong>过半数</strong>的确认(Leader对自己默认有一个ACK)后向所有的Follower发送commit，并将结果返回客户端</li>\n</ul>\n<blockquote>\n<p>对于上图的4各Follower，那就是一共有5个节点(不用计算Observer)，那就是需要3个确认，也就是两个Follower的ACK即可</p>\n</blockquote>\n<h2 id=\"写Follower\"><a href=\"#写Follower\" class=\"headerlink\" title=\"写Follower\"></a>写Follower</h2><ul>\n<li>Follower/Observer均可接受写请求，但不能直接处理，而需要将写请求转发给Leader处理</li>\n<li>除了多了一步请求转发，其它流程与直接写Leader无任何区别</li>\n</ul>\n<h2 id=\"读操作\"><a href=\"#读操作\" class=\"headerlink\" title=\"读操作\"></a>读操作</h2><p>所有服务器都可以接受客户端的读操作</p>\n<h2 id=\"领导选举算法-FastLeaderElection\"><a href=\"#领导选举算法-FastLeaderElection\" class=\"headerlink\" title=\"领导选举算法 - FastLeaderElection\"></a>领导选举算法 - FastLeaderElection</h2><p>FastLeaderElection 是基于TCP的</p>\n<h5 id=\"1-myid\"><a href=\"#1-myid\" class=\"headerlink\" title=\"1.myid\"></a>1.myid</h5><p>每个zookeeper服务器都要在数据文件夹下创建一个叫做myid的文件，这个文件包含整个zookeeper集群的唯一id</p>\n<h5 id=\"2-zxid\"><a href=\"#2-zxid\" class=\"headerlink\" title=\"2.zxid\"></a>2.zxid</h5><p>用来标识一次更新操作的提议ID，64位表示，高32位是Leader的轮次，从1开始，每换一个leader都会递增1，而低32位用来标记一次事务</p>\n<h5 id=\"3-服务器状态\"><a href=\"#3-服务器状态\" class=\"headerlink\" title=\"3.服务器状态\"></a>3.服务器状态</h5><ul>\n<li>LOOKING：不确定Leader状态，会发起Leader选举</li>\n<li>FOLLOWING：跟随者状态，表明当前服务器是follower状态</li>\n<li>LEADING：表示整个服务器是leader，它会维护与follower的心跳</li>\n<li>OBSERVING：观察者状态。表明当前服务器角色是Observer，与Folower唯一的不同在于不参与选举，也不参与集群写操作时的投票</li>\n</ul>\n<p><strong>4、选票数据结构</strong></p>\n<p> 每个服务器在进行领导选举时，会发送如下关键信息：</p>\n<ul>\n<li><strong>logicClock</strong> 每个服务器会维护一个自增的整数，名为logicClock，它表示这是该服务器发起的第多少轮投票</li>\n<li><strong>state</strong> 当前服务器的状态</li>\n<li><strong>self_id</strong> 当前服务器的myid</li>\n<li><strong>self_zxid</strong> 当前服务器上所保存的数据的最大zxid</li>\n<li><strong>vote_id</strong> 被推举的服务器的myid</li>\n<li><strong>vote_zxid</strong> 被推举的服务器上所保存的数据的最大zxid</li>\n</ul>\n<h3 id=\"投票流程\"><a href=\"#投票流程\" class=\"headerlink\" title=\"投票流程\"></a>投票流程</h3><ul>\n<li><p>当开始投票时，每个服务器都会先把票投给自己，然后进行广播，</p>\n</li>\n<li><p>接下来接受外部投票</p>\n</li>\n<li><p>判断选举轮次，如果外部投票的轮次大于自己的轮次，说明自己的轮次已经落后，就会将自己的轮次更新为这个轮次，然后进行选票PK</p>\n</li>\n<li><p>PK的规则是：比较自己推举的服务器的Zxid，也就是事务id，如果小的话，就会将票投给大的，并广播出去，如果相等，就会投给myid大的</p>\n</li>\n<li><p>如果有过半的服务器投给了某个服务器，投票结束，更换服务器的状态</p>\n</li>\n</ul>\n<blockquote>\n<p>每次某个FOLLOWER重启都会进行一次投票</p>\n</blockquote>\n<h2 id=\"使用Zookeeper来实现分布式的锁\"><a href=\"#使用Zookeeper来实现分布式的锁\" class=\"headerlink\" title=\"使用Zookeeper来实现分布式的锁\"></a>使用Zookeeper来实现分布式的锁</h2><p>zookeeper有持久型节点和非持久型节点，有可以细分为持久型顺序节点和非顺序节点，以此类推</p>\n<p>而zookeeper可以用<strong>非持久型节点</strong>来实现分布式锁</p>\n<h5 id=\"非公平锁的实现\"><a href=\"#非公平锁的实现\" class=\"headerlink\" title=\"非公平锁的实现\"></a>非公平锁的实现</h5><blockquote>\n<p>在zookeeper当中，非公平锁指的是锁被释放后，参与排队获取这个锁的所有客户端都可以去竞争，这和多线程中的非公平锁是有点区别的</p>\n</blockquote>\n<p>采用 <strong>非持久型非顺序</strong>节点来完成</p>\n<ul>\n<li>多个客户端尝试在zookeeper中创建非持久型非顺序节点，肯定只会有一个创建成功，这个客户端就获得了锁</li>\n<li>创建失败的客户端会在这个节点上注册一个Watch，一旦锁被释放，也就是节点被删除，那么那些客户端就会收到推送，再次进行抢占</li>\n</ul>\n<h5 id=\"公平锁的实现\"><a href=\"#公平锁的实现\" class=\"headerlink\" title=\"公平锁的实现\"></a>公平锁的实现</h5><blockquote>\n<p>公平锁指的是获取锁失败的客户端按照顺序去获得锁</p>\n</blockquote>\n<p>采用 <strong>非持久型顺序节点</strong> 来完成</p>\n<ul>\n<li>多个客户端会尝试获得锁的节点下创建出多个顺序节点，当尝试获取锁时，判断自己的节点是不是最小的，如果是则获取到锁</li>\n<li>如果获取锁失败，<strong>就注册Watch在比自己小的节点上，不是全部</strong>，所以当锁被释放时，只会有第一个排队的客户端收到Watch通知，其他不会</li>\n<li>收到通知后，并不会立即进行锁的获取，而是判断一下自己的顺序是否最小，如果不是，就还是会注册一个Watch到第一个比自己小的节点上</li>\n</ul>\n<h2 id=\"Zookeeper的Watch原理\"><a href=\"#Zookeeper的Watch原理\" class=\"headerlink\" title=\"Zookeeper的Watch原理\"></a>Zookeeper的Watch原理</h2><ul>\n<li>对于创建一个zookeeper客户端时，会创建出两个线程，一个是用来连接服务器的contect线程，一个负责监听的listener线程</li>\n<li>然后通过contect线程将监听事件发送给zookeeper服务器</li>\n<li>服务器将这个监听事件注册到监听列表当中</li>\n<li>当节点发生变化后，zookeeper服务器会将消息发送到listener线程当中</li>\n<li>listener线程调用precsss()方法进行处理</li>\n</ul>\n","feature":null,"text":"Zookeeper工作机制是一个分布式服务管理框架，负责存储和管理数据，然后接受观察者的注册，一旦这些数据发生变化，zookeeper就负责通知这些观察者做出相应的反应 Zookeeper服务器角色一般zookeeper都是以集群的形式存在的，是一个基于主从复制的高可用集群，每个...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"中间件","slug":"中间件","count":5,"path":"api/tags/中间件.json"},{"name":"底层原理","slug":"底层原理","count":4,"path":"api/tags/底层原理.json"},{"name":"Zookeeper","slug":"Zookeeper","count":1,"path":"api/tags/Zookeeper.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Zookeeper%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">Zookeeper工作机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Zookeeper%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%92%E8%89%B2\"><span class=\"toc-text\">Zookeeper服务器角色</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Zookeeper%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">Zookeeper怎么保证读写操作的一致性和可用性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%99Leader\"><span class=\"toc-text\">写Leader</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%99Follower\"><span class=\"toc-text\">写Follower</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">读操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95-FastLeaderElection\"><span class=\"toc-text\">领导选举算法 - FastLeaderElection</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-myid\"><span class=\"toc-text\">1.myid</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-zxid\"><span class=\"toc-text\">2.zxid</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">3.服务器状态</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%95%E7%A5%A8%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">投票流程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Zookeeper%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E9%94%81\"><span class=\"toc-text\">使用Zookeeper来实现分布式的锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">非公平锁的实现</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">公平锁的实现</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Zookeeper%E7%9A%84Watch%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Zookeeper的Watch原理</span></a></li></ol></li></ol>","author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"操作系统之内存管理","uid":"c48274d266bd8fce81f6183578ffb524","slug":"操作系统之内存管理","date":"2021-05-03T20:40:59.000Z","updated":"2022-09-15T14:22:17.560Z","comments":true,"path":"api/articles/操作系统之内存管理.json","keywords":null,"cover":[],"text":"逻辑地址和物理地址在进程当中，地址是从0号单元开始编址的，这叫做进程的逻辑地址 而物理地址是指的内存中物理单元的位置，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存当中获取，而逻辑地址和物理地址的转换称为地址重定位 内存保护系统需要保护用户进程不受其他用户进程的影响，...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","count":4,"path":"api/tags/计算机基础.json"},{"name":"操作系统","slug":"操作系统","count":3,"path":"api/tags/操作系统.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Hystrix底层原理","uid":"66fbda97c6061d29db33ae44cd19310f","slug":"Hystrix底层原理","date":"2021-05-03T20:31:56.000Z","updated":"2022-09-15T14:22:17.520Z","comments":true,"path":"api/articles/Hystrix底层原理.json","keywords":null,"cover":[],"text":"Hystrix 是什么？在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是依赖服务，有的时候某些依赖服务出现故障也是很正常的。 Hystrix可以提供那些功能Hystrix可以提供： 服务熔断 服务降级 服务限流 Hystrix 更加细节的设计原则 阻止任何一...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"中间件","slug":"中间件","count":5,"path":"api/tags/中间件.json"},{"name":"底层原理","slug":"底层原理","count":4,"path":"api/tags/底层原理.json"},{"name":"Hystrix","slug":"Hystrix","count":1,"path":"api/tags/Hystrix.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}