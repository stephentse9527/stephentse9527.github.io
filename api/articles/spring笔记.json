{"title":"Spring笔记","uid":"9fe79a5e2d58fcbcba8e87cdea7a0f13","slug":"spring笔记","date":"2022-05-21T12:37:38.000Z","updated":"2022-09-15T14:22:17.556Z","comments":true,"path":"api/articles/spring笔记.json","keywords":null,"cover":[],"content":"<h1 id=\"Spring笔记\"><a href=\"#Spring笔记\" class=\"headerlink\" title=\"Spring笔记\"></a>Spring笔记</h1><h4 id=\"Spring核心要点\"><a href=\"#Spring核心要点\" class=\"headerlink\" title=\"Spring核心要点\"></a>Spring核心要点</h4><ul>\n<li><strong>控制反转IOC</strong>：使用Spring之前，对象的使用和创建是绑定在一起的，除了主要的逻辑代码外，还需要为依赖的其他对象做很多复杂的创建工作，<strong>引入了Spring之后，就可以将创建和使用分离开</strong>，把对象的创建工作交由Spring框架来进行处理，需要用到的时候从Spring的容器中获取即可</li>\n<li><strong>面向切面AOP</strong>：不同业务模块的解耦</li>\n</ul>\n<h4 id=\"控制反转IOC\"><a href=\"#控制反转IOC\" class=\"headerlink\" title=\"控制反转IOC\"></a>控制反转IOC</h4><h5 id=\"配置方式\"><a href=\"#配置方式\" class=\"headerlink\" title=\"配置方式\"></a>配置方式</h5><ul>\n<li>XML、JavaConfig</li>\n<li>注解配置：@Component、@Controller、@Service、@Repository</li>\n</ul>\n<h5 id=\"依赖注入的方式\"><a href=\"#依赖注入的方式\" class=\"headerlink\" title=\"依赖注入的方式\"></a>依赖注入的方式</h5><ul>\n<li>构造方法注入（Construct注入），</li>\n<li>setter注入</li>\n<li>基于注解的注入（接口注入）<ul>\n<li>@Autowired：根据Type类型，c出现多个就根据name来匹配</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Spring-MVC\"><a href=\"#Spring-MVC\" class=\"headerlink\" title=\"Spring MVC\"></a>Spring MVC</h4><p>一个基于MVC模式设计的轻量级web 框架</p>\n<h5 id=\"Spring-MVC请求流程\"><a href=\"#Spring-MVC请求流程\" class=\"headerlink\" title=\"Spring MVC请求流程\"></a>Spring MVC请求流程</h5><img src=\"/post/spring%E7%AC%94%E8%AE%B0/spring-springframework-mvc-5.png\" class=\"\" title=\"spring-springframework-mvc-5\">\n\n<ul>\n<li><strong>首先用户发送请求——&gt;DispatcherServlet</strong>，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行 处理，作为统一访问点，进行全局的流程控制；进入DispatcherServlet之前还会有Filter，可以做preFilter以及postFilter</li>\n<li><strong>DispatcherServlet——&gt;HandlerMapping</strong>， HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一 个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；目的：获得请求映射到的handler处理器以及拦截器</li>\n<li><strong>DispatcherServlet——&gt;HandlerAdapter</strong>，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器， 即适配器设计模式的应用，从而很容易支持很多类型的处理器；</li>\n<li><strong>HandlerAdapter——&gt;处理器功能处理方法的调用</strong>，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处 理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；</li>\n<li><strong>ModelAndView 的逻辑视图名——&gt; ViewResolver</strong>，ViewResolver 将把逻辑视图名解析为具体的View，通过这种策 略模式，很容易更换其他视图技术；</li>\n<li><strong>View——&gt;渲染</strong>，View 会根据传进来的Model 模型数据进行渲染，此处的Model 实际是一个Map 数据结构，因此 很容易支持其他视图技术；</li>\n<li><strong>返回控制权给DispatcherServlet</strong>，由DispatcherServlet 返回响应给用户，到此一个流程结束。</li>\n</ul>\n<h4 id=\"Spring-IOC实现原理\"><a href=\"#Spring-IOC实现原理\" class=\"headerlink\" title=\"Spring IOC实现原理\"></a>Spring IOC实现原理</h4><h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><p>Spring顶层设计围绕<code>BeanFactory</code>和<code>BeanRegistry</code>来进行</p>\n<ul>\n<li><strong>BeanFactory：工厂模式定义了IOC容器的基本功能规范</strong></li>\n<li><strong>BeanRegistry： 向IOC容器手工注册 BeanDefinition 对象的方法</strong></li>\n</ul>\n<h5 id=\"BeanDefinition：各种Bean对象及其相互的关系\"><a href=\"#BeanDefinition：各种Bean对象及其相互的关系\" class=\"headerlink\" title=\"BeanDefinition：各种Bean对象及其相互的关系\"></a>BeanDefinition：各种Bean对象及其相互的关系</h5><p>Bean对象存在依赖嵌套等关系，所以设计者设计了BeanDefinition，它用来对Bean对象及关系定义；我们在理解时只需要抓住如下三个要点</p>\n<ul>\n<li><p>BeanDefinition 定义了各种Bean对象及其相互的关系</p>\n</li>\n<li><p> BeanDefinitionReader 这是BeanDefinition的解析器</p>\n</li>\n<li><p> BeanDefinitionHolder 这是BeanDefination的包装类，用来存储BeanDefinition，name以及aliases等</p>\n</li>\n</ul>\n<h5 id=\"IOC初始化流程\"><a href=\"#IOC初始化流程\" class=\"headerlink\" title=\"IOC初始化流程\"></a>IOC初始化流程</h5>\n\n<ul>\n<li>首先定位资源文件，通过ResourceLoader来完成资源文件的定位，并将其抽象成Resource对象</li>\n<li>接下来就是解析资源文件，通过 BeanDefinitionReader来完成定义信息的解析获取Bean的定义信息</li>\n<li>获取到BeanDefinition后，需要将其注册到IOC容器中，这由 IOC 实现 BeanDefinitionRegistry 接口来实现。注册过程就是在 IOC 容器内部维护的一个HashMap 来保存得到的 BeanDefinition 的过程。这个 HashMap 是 IoC 容器持有 bean 信息的场所，以后对 bean 的操作都是围绕这个HashMap 来实现的.</li>\n</ul>\n<h5 id=\"Bean实例化\"><a href=\"#Bean实例化\" class=\"headerlink\" title=\"Bean实例化\"></a>Bean实例化</h5><p>从定义信息中将BeanDefinition信息注册到IOC容器中后，只是保存了Bean信息，使用这些Bean的话还需要去进行Bean的实例化</p>\n<h4 id=\"Spring容器初始化\"><a href=\"#Spring容器初始化\" class=\"headerlink\" title=\"Spring容器初始化\"></a>Spring容器初始化</h4><blockquote>\n<p>创建IOC容器也就是创建一个ApplicationContext接口的实现类，</p>\n</blockquote>\n<ul>\n<li>Spring容器初始化时，会调用 <code>refresh()</code> 刷新IOC容器</li>\n<li>refresh 里面先调用 <code>prepareRefresh()</code> ，记录容器启动时间，标记已启动状态</li>\n<li>接下来会进入<code>obtainFreshBeanFactory()</code> 先重置BeanFactory，获得该BeanFactory对象</li>\n<li>接下来使用loadBeanDefinitions，将Bean的元信息存放到BeanDefinition当中</li>\n<li>获得BeanFactory后，进入prepareBeanFacotry为获得的BeanFacotory设置属性</li>\n<li>这时候所有的Bean定义已经加载完成，但是都没实例化，这一步可以去修改bean 的定义或者增加Bean的定义</li>\n<li>接下来会如果bean没有设置懒加载，就会加载这些单例bean</li>\n</ul>\n<h4 id=\"SpringBean的生命周期\"><a href=\"#SpringBean的生命周期\" class=\"headerlink\" title=\"SpringBean的生命周期\"></a>SpringBean的生命周期</h4><ul>\n<li><p>当要获取一个bean时，会调用getBean方法，实际的逻辑在doGetBean当中，首先会调用getSingleton方法，尝试从一级二级三级缓存中获取bean</p>\n</li>\n<li><p><strong>创建实例：</strong>如果都没有，就会调用createBean方法来创建bean，通过beanDefinition获取bean 的信息，创建出一个原始对象，并将这个Bean的创建工厂放到三级缓存中</p>\n</li>\n<li><p><strong>属性注入</strong>：接下来进行属性注入，初始化bean，把值和Bean的引用注入进Bean对应的属性中</p>\n</li>\n<li><p><strong>执行Aware方法</strong>：执行Aware将在初始化前如果bean实现了Aware接口，就会执行这些Aware方法</p>\n</li>\n<li><p><strong>Before-init</strong>：如果Bean实现了BeanPostProcessor，执行<code>postProcessbeforeInitialization</code>，相当于初始化前的操作</p>\n</li>\n<li><p><strong>init</strong>：如果Bean实现了InitializingBean，执行InitializingBean的afterPropertiesSet方法，相当于初始化Bean</p>\n</li>\n<li><p><strong>After-init：</strong>同样，如果实现了BeanPostProcess，就执行BeanPostProcessor的<code>postProcessAfterInitialization</code>方法，而将原始对象变成代理对象是发生在BeanPostProcessor的postProcessAfterInitialization中的wrapIfNecessary方法中</p>\n</li>\n<li><pre><code class=\"java\">protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;\n   if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123;\n      return bean;\n   &#125;\n   if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123;\n      return bean;\n   &#125;\n   if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;\n      this.advisedBeans.put(cacheKey, Boolean.FALSE);\n      return bean;\n   &#125;\n\n   // Create proxy if we have advice.\n   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n   if (specificInterceptors != DO_NOT_PROXY) &#123;\n      this.advisedBeans.put(cacheKey, Boolean.TRUE);\n      Object proxy = createProxy(\n            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n      this.proxyTypes.put(cacheKey, proxy.getClass());\n      return proxy;\n   &#125;\n\n   this.advisedBeans.put(cacheKey, Boolean.FALSE);\n   return bean;\n&#125;\n</code></pre>\n</li>\n<li><p>最后把完整的对象放进一级缓存中，同时删除其他缓存</p>\n</li>\n</ul>\n<h4 id=\"Spring解决循环依赖的问题\"><a href=\"#Spring解决循环依赖的问题\" class=\"headerlink\" title=\"Spring解决循环依赖的问题\"></a>Spring解决循环依赖的问题</h4><ul>\n<li>当要获取一个bean时，会调用getBean方法，实际的逻辑在doGetBean当中，首先会调用getSingleton方法，尝试从一级二级三级缓存中获取bean</li>\n<li>如果都没有，就会调用createBean方法来创建bean，通过beanDefinition获取bean 的信息，创建出一个原始对象，并将它放到三级缓存当中，三级缓存是以beanname做为key，创建工厂执行函数作为value的map</li>\n<li>当进行populaBean属性注入时，发现依赖B，就会去走getBean那一套，直到进行属性注入，这时候会发现A在三级缓存中已经有了，所以从三级缓存中拿出A的创建工厂，获得A的实例，B就顺利创建完成</li>\n<li>而回到A这边B也创建好了，只需要进行后面的初始化就可以了，然后将bean从二级缓存中放到一级缓存</li>\n</ul>\n<h4 id=\"为什么要三级缓存解决循环依赖\"><a href=\"#为什么要三级缓存解决循环依赖\" class=\"headerlink\" title=\"为什么要三级缓存解决循环依赖\"></a>为什么要三级缓存解决循环依赖</h4><p>如果单纯解决循环依赖，不需要第三级缓存，只需要一个缓存（三级缓存）即可</p>\n<p>而如果A进行了AOP操作的话，生成代理对象是在属性注入之后，如果发生循环依赖，在B的创建过程中获取A就需要提前获取到A的代理对象，而不是A的原始对象，所以要有第三个Map，来存放singletonFactory，在B中提前获得A的代理对象，这样B中注入的对象才会是和最后A的对象是一致的</p>\n<h4 id=\"为什么只有一级缓存是ConcHashMap，其他是普通Map\"><a href=\"#为什么只有一级缓存是ConcHashMap，其他是普通Map\" class=\"headerlink\" title=\"为什么只有一级缓存是ConcHashMap，其他是普通Map\"></a>为什么只有一级缓存是ConcHashMap，其他是普通Map</h4><p>因为二级缓存和三级缓存的put操作都会伴随着另一个的删除操作，要保证这两个操作的原子性，如果直接使用两个concmap，不能保证原子性，所以在对应的方法里面都是使用的sync关键字来直接加锁</p>\n","feature":null,"text":"Spring笔记Spring核心要点 控制反转IOC：使用Spring之前，对象的使用和创建是绑定在一起的，除了主要的逻辑代码外，还需要为依赖的其他对象做很多复杂的创建工作，引入了Spring之后，就可以将创建和使用分离开，把对象的创建工作交由Spring框架来进行处理，需要用到...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Spring%E7%AC%94%E8%AE%B0\"><span class=\"toc-text\">Spring笔记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Spring%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9\"><span class=\"toc-text\">Spring核心要点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC\"><span class=\"toc-text\">控制反转IOC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">配置方式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">依赖注入的方式</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Spring-MVC\"><span class=\"toc-text\">Spring MVC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Spring-MVC%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Spring MVC请求流程</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Spring-IOC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Spring IOC实现原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#BeanDefinition%EF%BC%9A%E5%90%84%E7%A7%8DBean%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E7%9B%B8%E4%BA%92%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">BeanDefinition：各种Bean对象及其相互的关系</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#IOC%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">IOC初始化流程</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Bean%E5%AE%9E%E4%BE%8B%E5%8C%96\"><span class=\"toc-text\">Bean实例化</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">Spring容器初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">SpringBean的生命周期</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Spring%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">Spring解决循环依赖的问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">为什么要三级缓存解决循环依赖</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%89%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%98%AFConcHashMap%EF%BC%8C%E5%85%B6%E4%BB%96%E6%98%AF%E6%99%AE%E9%80%9AMap\"><span class=\"toc-text\">为什么只有一级缓存是ConcHashMap，其他是普通Map</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JVM优化总结","uid":"b38e006a0ed784a6f0bb2ad5154dba4f","slug":"jvm优化总结","date":"2022-05-29T17:00:48.000Z","updated":"2022-09-15T14:22:17.544Z","comments":true,"path":"api/articles/jvm优化总结.json","keywords":null,"cover":null,"text":"JVM优化总结前置知识-元空间的知识元空间内存分配规则Metaspace 空间被分配在本地内存中(非堆上)，默认不限制内存使用，可以使用 MaxMetaspaceSize 指定最大值。MetaspaceSize 指定最小值，默认 21 M，在元空间申请的内存会分成一个一个的 Ma...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"kafka笔记","uid":"eaecd65a22befc3caf0b52e72c0ff526","slug":"kafka笔记","date":"2022-04-05T23:26:59.000Z","updated":"2022-09-15T14:22:17.544Z","comments":true,"path":"api/articles/kafka笔记.json","keywords":null,"cover":[],"text":"Kafka笔记工作中有大量的kafka使用场景，学习记录一下kafka的架构和原理 为什么要引入消息队列 各个组件间的解藕 流程之间的异步处理 流量控制 核心概念 Broker：broker指的就是一个kafka服务器 Producer：消息生产者，就是向broker发送消息的客...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"中间件","slug":"中间件","count":5,"path":"api/tags/中间件.json"},{"name":"kafka","slug":"kafka","count":1,"path":"api/tags/kafka.json"},{"name":"原理","slug":"原理","count":1,"path":"api/tags/原理.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}