{"title":"不同中间件的高并发架构","uid":"1b5a7d45e32f32d8b53151bc92581ac8","slug":"不同中间件的高并发架构","date":"2021-05-03T21:13:48.000Z","updated":"2022-09-15T14:22:17.560Z","comments":true,"path":"api/articles/不同中间件的高并发架构.json","keywords":null,"cover":[],"content":"<h1 id=\"不同中间件的高并发\"><a href=\"#不同中间件的高并发\" class=\"headerlink\" title=\"不同中间件的高并发\"></a>不同中间件的高并发</h1><h3 id=\"MySQL的高并发\"><a href=\"#MySQL的高并发\" class=\"headerlink\" title=\"MySQL的高并发\"></a>MySQL的高并发</h3><p>对于高并发阶段，MySQL 要做的就是基于主从复制架构，进行读写分离</p>\n<h5 id=\"MySQL主从复制的原理\"><a href=\"#MySQL主从复制的原理\" class=\"headerlink\" title=\"MySQL主从复制的原理\"></a>MySQL主从复制的原理</h5><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的</p>\n<img src=\"/post/%E4%B8%8D%E5%90%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/image-20210328121520698.png\" class=\"\" title=\"image-20210328121520698\">\n\n<h5 id=\"MySQL-主从同步延时问题（精华）\"><a href=\"#MySQL-主从同步延时问题（精华）\" class=\"headerlink\" title=\"MySQL 主从同步延时问题（精华）\"></a>MySQL 主从同步延时问题（精华）</h5><p>从库开启多个线程，并行读取relay log中不同库的日志，然后<strong>并行重放不同库的日志</strong>，这是<strong>库级别的并行</strong></p>\n<h5 id=\"解决主库数据丢失问题\"><a href=\"#解决主库数据丢失问题\" class=\"headerlink\" title=\"解决主库数据丢失问题\"></a>解决主库数据丢失问题</h5><p>主库写入binlog日志后，就会强制此时立即将数据同步到从库</p>\n<p>从库将日志写入自己本地的relay log后，会返回一个ack给主库</p>\n<p>主库接收到至少一个从库的ack之后才会认为写操作完成</p>\n<h3 id=\"Redis的高并发-主从架构模式\"><a href=\"#Redis的高并发-主从架构模式\" class=\"headerlink\" title=\"Redis的高并发-主从架构模式\"></a>Redis的高并发-主从架构模式</h3><p>主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的<strong>读请求全部走从节点</strong>。这样也可以很轻松实现水平扩容，<strong>支撑读高并发</strong>。</p>\n<img src=\"/post/%E4%B8%8D%E5%90%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/image-20210330101727740.png\" class=\"\" title=\"image-20210330101727740\">\n\n<h4 id=\"Redis-主从复制的核心原理\"><a href=\"#Redis-主从复制的核心原理\" class=\"headerlink\" title=\"Redis 主从复制的核心原理\"></a>Redis 主从复制的核心原理</h4><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC</code> 命令给 master node。</p>\n<ul>\n<li>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制。</li>\n<li>此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 <code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中</li>\n<li>接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</li>\n<li>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</li>\n</ul>\n<h4 id=\"主从复制的断点续传\"><a href=\"#主从复制的断点续传\" class=\"headerlink\" title=\"主从复制的断点续传\"></a>主从复制的断点续传</h4><p>从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份（增量复制）</p>\n<p>关键字：<strong>backlong, replica offset, run id</strong></p>\n<p>master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code> 。</p>\n<blockquote>\n<p>如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。</p>\n</blockquote>\n<h4 id=\"heartbeat\"><a href=\"#heartbeat\" class=\"headerlink\" title=\"heartbeat\"></a>heartbeat</h4><p>主从节点互相都会发送 heartbeat 信息。</p>\n<p>master 默认每隔 10 秒发送一次 heartbeat，slave node 每隔 1 秒发送一个 heartbeat。</p>\n<h4 id=\"异步复制\"><a href=\"#异步复制\" class=\"headerlink\" title=\"异步复制\"></a>异步复制</h4><p>master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。</p>\n","feature":null,"text":"不同中间件的高并发MySQL的高并发对于高并发阶段，MySQL 要做的就是基于主从复制架构，进行读写分离 MySQL主从复制的原理主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay ...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"系统设计","slug":"系统设计","count":2,"path":"api/tags/系统设计.json"},{"name":"高并发","slug":"高并发","count":1,"path":"api/tags/高并发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%90%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">不同中间件的高并发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MySQL%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">MySQL的高并发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">MySQL主从复制的原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#MySQL-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6%E9%97%AE%E9%A2%98%EF%BC%88%E7%B2%BE%E5%8D%8E%EF%BC%89\"><span class=\"toc-text\">MySQL 主从同步延时问题（精华）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E4%B8%BB%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">解决主库数据丢失问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Redis%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91-%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">Redis的高并发-主从架构模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">Redis 主从复制的核心原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0\"><span class=\"toc-text\">主从复制的断点续传</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#heartbeat\"><span class=\"toc-text\">heartbeat</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">异步复制</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ActiveMQ整合SpringBoot","uid":"a4246540661d717dae121d955eded9b9","slug":"ActiveMQ整合SpringBoot","date":"2021-05-03T21:16:08.000Z","updated":"2022-09-15T14:22:17.512Z","comments":true,"path":"api/articles/ActiveMQ整合SpringBoot.json","keywords":null,"cover":null,"text":"ActiveMQ 整合 SpringBoot引入 activemq 依赖&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-act...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"中间件","slug":"中间件","count":5,"path":"api/tags/中间件.json"},{"name":"ActiveMQ","slug":"ActiveMQ","count":1,"path":"api/tags/ActiveMQ.json"},{"name":"使用心得","slug":"使用心得","count":2,"path":"api/tags/使用心得.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MySQL之索引底层原理","uid":"8cad178e2e225e1e2dd25040facb3e5a","slug":"MySQL之索引底层原理","date":"2021-05-03T21:08:22.000Z","updated":"2022-09-15T14:22:17.520Z","comments":true,"path":"api/articles/MySQL之索引底层原理.json","keywords":null,"cover":[],"text":"InnoDB 页结构页是MySQL管理存储空间的基本单位，一个页的大小一般是16KB，记录是被存放在页中的，如果记录占用的空间太大还可能造成行溢出现象，这会导致一条记录被分散存储在多个页中。 页的本质就是一块16KB大小的存储空间，InnoDB为了不同的目的而把页分为不同的类型，...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"底层原理","slug":"底层原理","count":4,"path":"api/tags/底层原理.json"},{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"}],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}