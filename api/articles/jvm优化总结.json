{"title":"JVM优化总结","uid":"b38e006a0ed784a6f0bb2ad5154dba4f","slug":"jvm优化总结","date":"2022-05-29T17:00:48.000Z","updated":"2022-09-15T14:22:17.544Z","comments":true,"path":"api/articles/jvm优化总结.json","keywords":null,"cover":null,"content":"<h1 id=\"JVM优化总结\"><a href=\"#JVM优化总结\" class=\"headerlink\" title=\"JVM优化总结\"></a>JVM优化总结</h1><h2 id=\"前置知识-元空间的知识\"><a href=\"#前置知识-元空间的知识\" class=\"headerlink\" title=\"前置知识-元空间的知识\"></a>前置知识-元空间的知识</h2><h4 id=\"元空间内存分配规则\"><a href=\"#元空间内存分配规则\" class=\"headerlink\" title=\"元空间内存分配规则\"></a>元空间内存分配规则</h4><p>Metaspace 空间被分配在本地内存中(非堆上)，默认不限制内存使用，可以使用 MaxMetaspaceSize 指定最大值。MetaspaceSize 指定最小值，默认 <code>21 </code>M，在元空间申请的内存会分成一个一个的 Matachunk，以Matachunk为单位分配给类加载器，每个 Metachunk 对应唯一一个类加载器，一个类加载器可以有多个 Metachunk</p>\n<ul>\n<li><strong>used</strong>: chunk 中已经使用的 block 内存，这些 block 中都加载了类的数据。</li>\n<li><strong>capacity</strong>：在使用的 chunk 内存。</li>\n<li><strong>commited</strong>：所有分配的 chunk 内存，这里包含空闲可以再次被利用的。</li>\n<li><strong>reserved</strong>：是可以使用的内存大小</li>\n</ul>\n<h4 id=\"元空间出发Full-GC时机\"><a href=\"#元空间出发Full-GC时机\" class=\"headerlink\" title=\"元空间出发Full GC时机\"></a>元空间出发Full GC时机</h4><p>参数 <code>MinMetaspaceFreeRatio</code>，默认40，也就是40%，</p>\n<h2 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h2><p>一个关于JVM 元空间mataspace OOM的优化实例，服务频繁出现FULL GC</p>\n<p>解决过程</p>\n<ul>\n<li><p>打开了GC日志，然后发现GC日志当中</p>\n<p>元空间使用信息中，<strong>capacity比use多出来很多，说明分配了很多chunk，占用了很多空间，但是却没有完全使用它</strong></p>\n<p>所以推断出mataspace中应该是碎片化了</p>\n<p>因为chunk分配是根据类加载器来分配的，所以只用那三个类加载器一般是不会出现碎片化的，所以<strong>初步定位为有大量的自定义类加载器加载了一堆类进来</strong></p>\n</li>\n<li><p>所以dump jvm内存下来，然后观察Objects使用较高的元素，排除Java内部的那些常见类之后，发现一个叫做<code>DelegatingClassLoader</code>数量特别高，然后再分析是谁引用了这个类加载器</p>\n</li>\n<li><p> 然后发现是因为反射调用method的方法引用的，所以呢就初步判定了是反射造成的</p>\n</li>\n<li><p>最后发现，原来是Method类中，invoke方法里面会有一个优化，指的是有一个膨胀阈值，为15，当发现一个类中的方法被调用超过阈值15次时，会做一个优化，会使用字节码的形式，为这个方法去定义出一个类，这个类的类加载器叫做<code>DelegatingClassLoader</code>，所以创建了大量的类加载器</p>\n</li>\n<li><p>最后在定位到代码上，发现我们需要传递上下文对象到一个排序rank引擎中给召回item做一次精排打分，需要把上下文对象做一次转换，所以大量使用了BeanUtils.copy…的方法，找个方法里面就是通过invoke对象的getSet方法来做属性赋值的，所以问题就定位到了</p>\n</li>\n</ul>\n","feature":null,"text":"JVM优化总结前置知识-元空间的知识元空间内存分配规则Metaspace 空间被分配在本地内存中(非堆上)，默认不限制内存使用，可以使用 MaxMetaspaceSize 指定最大值。MetaspaceSize 指定最小值，默认 21 M，在元空间申请的内存会分成一个一个的 Ma...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">JVM优化总结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">前置知识-元空间的知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99\"><span class=\"toc-text\">元空间内存分配规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%A9%BA%E9%97%B4%E5%87%BA%E5%8F%91Full-GC%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">元空间出发Full GC时机</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">案例</span></a></li></ol></li></ol>","author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2022-09-15T14:22:17.544Z","updated":"2022-09-15T14:22:17.544Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the ...","link":"","photos":[],"count_time":{"symbolsCount":430,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Spring笔记","uid":"9fe79a5e2d58fcbcba8e87cdea7a0f13","slug":"spring笔记","date":"2022-05-21T12:37:38.000Z","updated":"2022-09-15T14:22:17.556Z","comments":true,"path":"api/articles/spring笔记.json","keywords":null,"cover":[],"text":"Spring笔记Spring核心要点 控制反转IOC：使用Spring之前，对象的使用和创建是绑定在一起的，除了主要的逻辑代码外，还需要为依赖的其他对象做很多复杂的创建工作，引入了Spring之后，就可以将创建和使用分离开，把对象的创建工作交由Spring框架来进行处理，需要用到...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"谢华客","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"记录一些笔记和心情的地方","socials":{"github":"https://github.com/stephentse9527","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}